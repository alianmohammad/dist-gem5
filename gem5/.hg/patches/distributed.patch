# HG changeset patch
# Parent d660f0d38e3baa1bcaf5a570c270ffa8d98e1d45
distributed: baseline patch for distributed simulations

diff --git a/configs/common/FSConfig.py b/configs/common/FSConfig.py
--- a/configs/common/FSConfig.py
+++ b/configs/common/FSConfig.py
@@ -645,3 +645,39 @@
         self.etherlink.dump = Parent.etherdump
 
     return self
+
+
+def makeMultiRoot(testSystem,
+                  rank,
+                  size,
+                  server_name,
+                  server_port,
+                  sync_repeat,
+                  sync_start,
+                  linkspeed,
+                  linkdelay,
+                  dumpfile):
+    self = Root(full_system = True)
+    self.testsys = testSystem
+
+    self.etherlink = MultiEtherLink(speed = linkspeed,
+                                    delay = linkdelay,
+                                    multi_rank = rank,
+                                    multi_size = size,
+                                    server_name = server_name,
+                                    server_port = server_port,
+                                    sync_start = sync_start,
+                                    sync_repeat = sync_repeat)
+
+    if hasattr(testSystem, 'realview'):
+        self.etherlink.int0 = Parent.testsys.realview.ethernet.interface
+    elif hasattr(testSystem, 'tsunami'):
+        self.etherlink.int0 = Parent.testsys.tsunami.ethernet.interface
+    else:
+        fatal("Don't know how to connect MultiEtherLink to this system")
+
+    if dumpfile:
+        self.etherdump = EtherDump(file=dumpfile)
+        self.etherlink.dump = Parent.etherdump
+
+    return self
diff --git a/configs/common/Options.py b/configs/common/Options.py
--- a/configs/common/Options.py
+++ b/configs/common/Options.py
@@ -275,10 +275,38 @@
     # Benchmark options
     parser.add_option("--dual", action="store_true",
                       help="Simulate two systems attached with an ethernet link")
+    parser.add_option("--multi", action="store_true",
+                      help="Parallel multi gem5 simulation.")
+    parser.add_option("--multi-rank", default=0, action="store", type="int",
+                      help="Rank of this system within the multi gem5 run.")
+    parser.add_option("--multi-size", default=0, action="store", type="int",
+                      help="Number of gem5 processes within the multi gem5 run.")
+    parser.add_option("--multi-server-name",
+                      default="localhost",
+                      action="store", type="string",
+                      help="Name of the message server host\nDEFAULT: localhost")
+    parser.add_option("--multi-server-port",
+                      default=2200,
+                      action="store", type="int",
+                      help="Message server listen port\nDEFAULT: 2200")
+    parser.add_option("--multi-sync-repeat",
+                      default="0us",
+                      action="store", type="string",
+                      help="Repeat interval for synchronisation barriers among multi gem5 processes\nDEFAULT: --ethernet-linkdelay")
+    parser.add_option("--multi-sync-start",
+                      default="5200000000000t",
+                      action="store", type="string",
+                      help="Time to schedule the first multi synchronisation barrier\nDEFAULT:5200000000000t")
     parser.add_option("-b", "--benchmark", action="store", type="string",
                       dest="benchmark",
                       help="Specify the benchmark to run. Available benchmarks: %s"\
                       % DefinedBenchmarks)
+    parser.add_option("--ethernet-linkspeed", default="10Gbps",
+                        action="store", type="string",
+                        help="Link speed in bps\nDEFAULT: 10Gbps")
+    parser.add_option("--ethernet-linkdelay", default="10us",
+                      action="store", type="string",
+                      help="Link delay in seconds\nDEFAULT: 10us")
 
     # Metafile options
     parser.add_option("--etherdump", action="store", type="string", dest="etherdump",
diff --git a/configs/example/fs.py b/configs/example/fs.py
--- a/configs/example/fs.py
+++ b/configs/example/fs.py
@@ -328,6 +328,18 @@
 if len(bm) == 2:
     drive_sys = build_drive_system(np)
     root = makeDualRoot(True, test_sys, drive_sys, options.etherdump)
+elif len(bm) == 1 and options.multi:
+    # This system is part of a multi-gem5 simulation
+    root = makeMultiRoot(test_sys,
+                         options.multi_rank,
+                         options.multi_size,
+                         options.multi_server_name,
+                         options.multi_server_port,
+                         options.multi_sync_repeat,
+                         options.multi_sync_start,
+                         options.ethernet_linkspeed,
+                         options.ethernet_linkdelay,
+                         options.etherdump);
 elif len(bm) == 1:
     root = Root(full_system=True, system=test_sys)
 else:
diff --git a/src/arch/alpha/isa/decoder.isa b/src/arch/alpha/isa/decoder.isa
--- a/src/arch/alpha/isa/decoder.isa
+++ b/src/arch/alpha/isa/decoder.isa
@@ -982,7 +982,7 @@
                 PseudoInst::loadsymbol(xc->tcBase());
             }}, No_OpClass, IsNonSpeculative);
             0x30: initparam({{
-                Ra = PseudoInst::initParam(xc->tcBase());
+                Ra = PseudoInst::initParam(xc->tcBase(), R16);
             }});
             0x40: resetstats({{
                 PseudoInst::resetstats(xc->tcBase(), R16, R17);
diff --git a/src/arch/arm/isa/insts/m5ops.isa b/src/arch/arm/isa/insts/m5ops.isa
--- a/src/arch/arm/isa/insts/m5ops.isa
+++ b/src/arch/arm/isa/insts/m5ops.isa
@@ -276,13 +276,13 @@
     exec_output += PredOpExecute.subst(loadsymbolIop)
 
     initparamCode = '''
-    uint64_t ip_val  = PseudoInst::initParam(xc->tcBase());
+    uint64_t ip_val  = PseudoInst::initParam(xc->tcBase(), join32to64(R1, R0));
     R0 = bits(ip_val, 31, 0);
     R1 = bits(ip_val, 63, 32);
     '''
 
     initparamCode64 = '''
-    X0 = PseudoInst::initParam(xc->tcBase());
+    X0 = PseudoInst::initParam(xc->tcBase(), X0);
     '''
 
     initparamIop = InstObjParams("initparam", "Initparam", "PredOp",
diff --git a/src/arch/x86/isa/decoder/two_byte_opcodes.isa b/src/arch/x86/isa/decoder/two_byte_opcodes.isa
--- a/src/arch/x86/isa/decoder/two_byte_opcodes.isa
+++ b/src/arch/x86/isa/decoder/two_byte_opcodes.isa
@@ -173,7 +173,7 @@
                         PseudoInst::m5fail(xc->tcBase(), Rdi, Rsi);
                     }}, IsNonSpeculative);
                     0x30: m5initparam({{
-                        Rax = PseudoInst::initParam(xc->tcBase());
+                        Rax = PseudoInst::initParam(xc->tcBase(), Rdi);
                     }}, IsNonSpeculative);
                     0x31: m5loadsymbol({{
                         PseudoInst::loadsymbol(xc->tcBase());
diff --git a/src/dev/Ethernet.py b/src/dev/Ethernet.py
--- a/src/dev/Ethernet.py
+++ b/src/dev/Ethernet.py
@@ -66,8 +66,9 @@
     delay_var = Param.Latency('0ns', "packet transmit delay variability")
     speed = Param.NetworkBandwidth('1Gbps', "link speed")
     dump = Param.EtherDump(NULL, "dump object")
-    multi_rank  =  Param.UInt32('0', "Rank of the this gem5 process (multi run)")
-    sync_start  = Param.Latency('5200000000000t', "first multi sync barrier")
+    multi_rank = Param.UInt32('0', "Rank of this gem5 process (multi run)")
+    multi_size = Param.UInt32('1', "Number of gem5 processes (multi run)")
+    sync_start = Param.Latency('5200000000000t', "first multi sync barrier")
     sync_repeat = Param.Latency('10us', "multi sync barrier repeat")
     server_name = Param.String('localhost', "Message server name")
     server_port = Param.UInt32('2200', "Message server port")
diff --git a/src/dev/multi_etherlink.cc b/src/dev/multi_etherlink.cc
--- a/src/dev/multi_etherlink.cc
+++ b/src/dev/multi_etherlink.cc
@@ -75,15 +75,26 @@
     : EtherObject(p)
 {
     DPRINTF(MultiEthernet,"MultiEtherLink::MultiEtherLink() "
-            "link delay:%llu\n", p->delay);
+            "link delay:%llu ticksPerByte:%f\n", p->delay, p->speed);
 
     txLink = new TxLink(name() + ".link0", this, p->speed, p->delay_var,
                         p->dump);
     rxLink = new RxLink(name() + ".link1", this, p->delay, p->dump);
 
+    Tick sync_repeat;
+    if (p->sync_repeat != 0) {
+        if (p->sync_repeat != p->delay)
+            warn("MultiEtherLink(): sync_repeat is %lu and linkdelay is %lu",
+                 p->sync_repeat, p->delay);
+        sync_repeat = p->sync_repeat;
+    } else {
+        sync_repeat = p->delay;
+    }
+
     // create the multi (TCP) interface to talk to the peer gem5 processes.
-    multiIface = new TCPIface(p->server_name, p->server_port, p->multi_rank,
-                              p->sync_start, p->sync_repeat, this);
+    multiIface = new TCPIface(p->server_name, p->server_port,
+                              p->multi_rank, p->multi_size,
+                              p->sync_start, sync_repeat, this);
 
     localIface = new LocalIface(name() + ".int0", txLink, rxLink, multiIface);
 }
@@ -107,40 +118,34 @@
     return localIface;
 }
 
-void MultiEtherLink::memWriteback()
-{
-    DPRINTF(MultiEthernet,"MultiEtherLink::memWriteback() called\n");
-    multiIface->drainDone();
-}
-
 void
 MultiEtherLink::serialize(CheckpointOut &cp) const
 {
-    multiIface->serialize("multiIface", cp);
-    txLink->serialize("txLink", cp);
-    rxLink->serialize("rxLink", cp);
+    multiIface->serializeSection(cp, "multiIface");
+    txLink->serializeSection(cp, "txLink");
+    rxLink->serializeSection(cp, "rxLink");
 }
 
 void
 MultiEtherLink::unserialize(CheckpointIn &cp)
 {
-    multiIface->unserialize("multiIface", cp);
-    txLink->unserialize("txLink", cp);
-    rxLink->unserialize("rxLink", cp);
+    multiIface->unserializeSection(cp, "multiIface");
+    txLink->unserializeSection(cp, "txLink");
+    rxLink->unserializeSection(cp, "rxLink");
 }
 
 void
 MultiEtherLink::init()
 {
     DPRINTF(MultiEthernet,"MultiEtherLink::init() called\n");
-    multiIface->initRandom();
+    multiIface->init();
 }
 
 void
 MultiEtherLink::startup()
 {
     DPRINTF(MultiEthernet,"MultiEtherLink::startup() called\n");
-    multiIface->startPeriodicSync();
+    multiIface->startup();
 }
 
 void
@@ -211,36 +216,36 @@
 }
 
 void
-MultiEtherLink::Link::serialize(const string &base, CheckpointOut &cp) const
+MultiEtherLink::Link::serialize(CheckpointOut &cp) const
 {
     bool packet_exists = (packet != nullptr);
-    paramOut(cp, base + ".packet_exists", packet_exists);
+    SERIALIZE_SCALAR(packet_exists);
     if (packet_exists)
-        packet->serialize(base + ".packet", cp);
+        packet->serialize("packet", cp);
 
     bool event_scheduled = event->scheduled();
-    paramOut(cp, base + ".event_scheduled", event_scheduled);
+    SERIALIZE_SCALAR(event_scheduled);
     if (event_scheduled) {
         Tick event_time = event->when();
-        paramOut(cp, base + ".event_time", event_time);
+        SERIALIZE_SCALAR(event_time);
     }
 }
 
 void
-MultiEtherLink::Link::unserialize(const string &base, CheckpointIn &cp)
+MultiEtherLink::Link::unserialize(CheckpointIn &cp)
 {
     bool packet_exists;
-    paramIn(cp, base + ".packet_exists", packet_exists);
+    UNSERIALIZE_SCALAR(packet_exists);
     if (packet_exists) {
         packet = make_shared<EthPacketData>(16384);
-        packet->unserialize(base + ".packet", cp);
+        packet->unserialize("packet", cp);
     }
 
     bool event_scheduled;
-    paramIn(cp, base + ".event_scheduled", event_scheduled);
+    UNSERIALIZE_SCALAR(event_scheduled);
     if (event_scheduled) {
         Tick event_time;
-        paramIn(cp, base + ".event_time", event_time);
+        UNSERIALIZE_SCALAR(event_time);
         parent->schedule(*event, event_time);
     }
 }
diff --git a/src/dev/multi_etherlink.hh b/src/dev/multi_etherlink.hh
--- a/src/dev/multi_etherlink.hh
+++ b/src/dev/multi_etherlink.hh
@@ -72,7 +72,7 @@
      * The link will encapsulate and transfer Ethernet packets to/from
      * the message server.
      */
-    class Link
+    class Link : public Serializable
     {
       protected:
         std::string objName;
@@ -95,8 +95,8 @@
         bool busy() const { return (bool)packet; }
         void setLocalInt(LocalIface *i) { assert(!localIface); localIface=i; }
 
-        void serialize(const std::string &base, CheckpointOut &cp) const;
-        void unserialize(const std::string &base, CheckpointIn &cp);
+        void serialize(CheckpointOut &cp) const M5_ATTR_OVERRIDE;
+        void unserialize(CheckpointIn &cp) M5_ATTR_OVERRIDE;
     };
 
     /**
@@ -224,9 +224,8 @@
     virtual EtherInt *getEthPort(const std::string &if_name,
                                  int idx) M5_ATTR_OVERRIDE;
 
-    void memWriteback() M5_ATTR_OVERRIDE;
-    void init() M5_ATTR_OVERRIDE;
-    void startup() M5_ATTR_OVERRIDE;
+    virtual void init() M5_ATTR_OVERRIDE;
+    virtual void startup() M5_ATTR_OVERRIDE;
 
     void serialize(CheckpointOut &cp) const M5_ATTR_OVERRIDE;
     void unserialize(CheckpointIn &cp) M5_ATTR_OVERRIDE;
diff --git a/src/dev/multi_iface.cc b/src/dev/multi_iface.cc
--- a/src/dev/multi_iface.cc
+++ b/src/dev/multi_iface.cc
@@ -60,172 +60,146 @@
 unsigned MultiIface::recvThreadsNum = 0;
 MultiIface *MultiIface::master = nullptr;
 
-bool
-MultiIface::Sync::run(SyncTrigger t, Tick sync_tick)
+void
+MultiIface::Sync::init(Tick start_tick, Tick repeat_tick)
+{
+    if (start_tick < nextAt) {
+        nextAt = start_tick;
+        inform("Next multi synchronisation tick is changed to %lu.\n", nextAt);
+    }
+
+    if (repeat_tick == 0)
+        panic("Multi synchronisation interval must be greater than zero");
+
+    if (repeat_tick < nextRepeat) {
+        nextRepeat = repeat_tick;
+        inform("Multi synchronisation interval is changed to %lu.\n",
+               nextRepeat);
+    }
+}
+
+void
+MultiIface::Sync::run(bool same_tick)
 {
     std::unique_lock<std::mutex> sync_lock(lock);
+    Header header;
 
-    trigger = t;
-    if (trigger != SyncTrigger::periodic) {
-        DPRINTF(MultiEthernet,"MultiIface::Sync::run() trigger:%d\n",
-                (unsigned)trigger);
-    }
+    assert(waitNum == 0);
+    waitNum = MultiIface::recvThreadsNum;
+    // initiate the global synchronisation
+    header.msgType = MsgType::cmdSyncReq;
+    header.sendTick = curTick();
+    header.sameTick = same_tick;
+    header.syncRepeat = nextRepeat;
 
-    switch (state) {
-      case SyncState::asyncCkpt:
-        switch (trigger) {
-          case SyncTrigger::ckpt:
-            assert(MultiIface::syncEvent->interrupted == false);
-            state = SyncState::busy;
-            break;
-          case SyncTrigger::periodic:
-            if (waitNum == 0) {
-                // So all recv threads got an async checkpoint request already
-                // and a simExit is scheduled at the end of the current tick
-                // (i.e. it is a periodic sync scheduled at the same tick as
-                // the simExit).
-                state = SyncState::idle;
-                DPRINTF(MultiEthernet,"MultiIface::Sync::run() interrupted "
-                "due to async ckpt scheduled\n");
-                return false;
-            } else {
-                // we still need to wait for some receiver thread to get the
-                // aysnc ckpt request. We are going to proceed as 'interrupted'
-                // periodic sync.
-                state = SyncState::interrupted;
-                DPRINTF(MultiEthernet,"MultiIface::Sync::run() interrupted "
-                "due to ckpt request is coming in\n");
-            }
-            break;
-          case SyncTrigger::atomic:
-            assert(trigger != SyncTrigger::atomic);
-        }
-        break;
-      case SyncState::idle:
-        state = SyncState::busy;
-        break;
-        // Only one sync can be active at any time
-      case SyncState::interrupted:
-      case SyncState::busy:
-        assert(state != SyncState::interrupted);
-        assert(state != SyncState::busy);
-        break;
-    }
-    // Kick-off the sync unless we are in the middle of an interrupted
-    // periodic sync
-    if (state != SyncState::interrupted) {
-        assert(waitNum == 0);
-        waitNum = MultiIface::recvThreadsNum;
-        // initiate the global synchronisation
-        assert(MultiIface::master != nullptr);
-        MultiIface::master->syncRaw(triggerToMsg[(unsigned)trigger], sync_tick);
-    }
+    MultiIface::master->sendCmd(header);
     // now wait until all receiver threads complete the synchronisation
     auto lf = [this]{ return waitNum == 0; };
     cv.wait(sync_lock, lf);
-
-    // we are done
-    assert(state == SyncState::busy || state == SyncState::interrupted);
-    bool ret = (state != SyncState::interrupted);
-    state = SyncState::idle;
-    return ret;
+    // global barrier is done
 }
 
 void
-MultiIface::Sync::progress(MsgType msg)
+MultiIface::Sync::progress(Tick max_req_tick,
+                           Tick next_repeat,
+                           bool do_ckpt,
+                           bool do_exit)
 {
     std::unique_lock<std::mutex> sync_lock(lock);
+    assert(waitNum > 0);
+    assert(waitNum == 1 || (nextAt == max_req_tick && nextRepeat == next_repeat &&
+                            doCkpt == do_ckpt && doExit == do_exit));
 
-    switch (msg) {
-      case MsgType::cmdAtomicSyncAck:
-        assert(state == SyncState::busy && trigger == SyncTrigger::atomic);
-        break;
-      case MsgType::cmdPeriodicSyncAck:
-        assert(state == SyncState::busy && trigger == SyncTrigger::periodic);
-        break;
-      case MsgType::cmdCkptSyncAck:
-        assert(state == SyncState::busy && trigger == SyncTrigger::ckpt);
-        break;
-      case MsgType::cmdCkptSyncReq:
-        switch (state) {
-          case SyncState::busy:
-            if (trigger == SyncTrigger::ckpt) {
-                // We are already in a checkpoint sync but got another ckpt
-                // sync request. This may happen if two (or more) peer gem5
-                // processes try to start a ckpt nearly at the same time.
-                // Incrementing waitNum here (before decrementing it below)
-                // effectively results in ignoring this new ckpt sync request.
-                waitNum++;
-                break;
-            }
-            assert (waitNum == recvThreadsNum);
-            state = SyncState::interrupted;
-            // we need to fall over here to handle "recvThreadsNum == 1" case
-          case SyncState::interrupted:
-            assert(trigger == SyncTrigger::periodic);
-            assert(waitNum >= 1);
-            if (waitNum == 1) {
-                exitSimLoop("checkpoint");
-            }
-            break;
-          case SyncState::idle:
-            // There is no on-going sync so we got an async ckpt request. If we
-            // are the only receiver thread then we need to schedule the
-            // checkpoint. Otherwise, only change the state to 'asyncCkpt' and
-            // let the last receiver thread to schedule the checkpoint at the
-            // 'asyncCkpt' case.
-            // Note that a periodic or resume sync may start later and that can
-            // trigger a state change to 'interrupted' (so the checkpoint may
-            // get scheduled at 'interrupted' case finally).
-            assert(waitNum == 0);
-            state = SyncState::asyncCkpt;
-            waitNum = MultiIface::recvThreadsNum;
-            // we need to fall over here to handle "recvThreadsNum == 1" case
-          case SyncState::asyncCkpt:
-            assert(waitNum >= 1);
-            if (waitNum == 1)
-                exitSimLoop("checkpoint");
-            break;
-          default:
-            panic("Unexpected state for checkpoint request message");
-            break;
-        }
-        break;
-      default:
-        panic("Unknown msg type");
-        break;
-    }
+    nextAt = max_req_tick;
+    nextRepeat = next_repeat;
+    doCkpt = do_ckpt;
+    doExit = do_exit;
+
     waitNum--;
-    assert(state != SyncState::idle);
-    // Notify the simultaion thread if there is an on-going sync.
-    if (state != SyncState::asyncCkpt) {
+    // Notify the simulation thread if the on-going sync is complete
+    if (waitNum == 0) {
         sync_lock.unlock();
         cv.notify_one();
     }
 }
 
-void MultiIface::SyncEvent::start(Tick start, Tick interval)
+void
+MultiIface::Sync::requestCkpt()
 {
-    assert(!scheduled());
-    if (interval == 0)
-        panic("Multi synchronisation period must be greater than zero");
-    repeat = interval;
-    schedule(start);
+   std::lock_guard<std::mutex> sync_lock(lock);
+   Header header;
+   header.msgType = MsgType::cmdCkptReq;
+   master->sendCmd(header);
+   needCkpt = true;
 }
 
 void
-MultiIface::SyncEvent::adjust(Tick start_tick, Tick repeat_tick)
+MultiIface::Sync::requestExit()
 {
-    // The new multi interface may require earlier start of the
-    // synchronisation.
-    assert(scheduled() == true);
-    if (start_tick < when())
-        reschedule(start_tick);
-    // The new multi interface may require more frequent synchronisation.
-    if (repeat == 0)
-        panic("Multi synchronisation period must be greater than zero");
-    if (repeat < repeat_tick)
-        repeat = repeat_tick;
+   std::lock_guard<std::mutex> sync_lock(lock);
+   Header header;
+   header.msgType = MsgType::cmdExitReq;
+   master->sendCmd(header);
+   needExit = true;
+}
+
+void
+MultiIface::Sync::drainComplete()
+{
+    if (!isCkptSyncDone) {
+        // The first MultiIface object called right before writing the
+        // checkpoint. We need to drain the underlying physical network here
+        // Note that other gem5 peers may enter this barrier at different
+        // ticks due to draining.
+        run(false);
+        // Only the "first" MultiIface object has to perform the sync
+        isCkptSyncDone = true;
+    }
+}
+
+void
+MultiIface::Sync::serialize(CheckpointOut &cp) const
+{
+    SERIALIZE_SCALAR(needExit);
+}
+
+void
+MultiIface::Sync::unserialize(CheckpointIn &cp)
+{
+    UNSERIALIZE_SCALAR(needExit);
+}
+
+void
+MultiIface::SyncEvent::start()
+{
+    // Note that this may be called either from startup() or drainResume()
+
+    // Store our initial start and repeat value
+    Tick start = MultiIface::sync->nextAt;
+    repeat = MultiIface::sync->nextRepeat;
+    // Do a global barrier to figure out the common start tick and repeat
+    // for periodic sync
+    MultiIface::sync->run(curTick() == 0);
+
+    assert(!MultiIface::sync->doCkpt);
+    assert(!MultiIface::sync->doExit);
+    assert(MultiIface::sync->nextAt >= curTick());
+    assert(MultiIface::sync->nextRepeat <= repeat);
+
+    // if this is called at tick 0 then we use the config start param otherwise
+    // the maximum of the current tick of all gem5 peers
+    if (curTick() == 0) {
+        assert(!scheduled());
+        assert(MultiIface::sync->nextAt == 0);
+        schedule(start);
+    } else {
+        if (scheduled())
+            reschedule(MultiIface::sync->nextAt);
+        else
+            schedule(MultiIface::sync->nextAt);
+    }
+    inform("Multi sync scheduled at %lu and repeats %lu\n",  when(),
+           MultiIface::sync->nextRepeat);
 }
 
 void
@@ -235,18 +209,6 @@
      * Note that this is a global event so this process method will be called
      * by only exactly one thread.
      */
-    // if we are draining the system then we must not start a periodic sync (as
-    // it is not sure that all peer gem5 will reach this tick before taking
-    // the checkpoint).
-    if (isDraining == true) {
-        assert(interrupted == false);
-        interrupted = true;
-        DPRINTF(MultiEthernet,"MultiIface::SyncEvent::process() interrupted "
-                "due to draining\n");
-        return;
-    }
-    if (interrupted == false)
-        scheduledAt = curTick();
     /*
      * We hold the eventq lock at this point but the receiver thread may
      * need the lock to schedule new recv events while waiting for the
@@ -254,70 +216,206 @@
      * Note that the other simulation threads also release their eventq
      * locks while waiting for us due to the global event semantics.
      */
-    curEventQueue()->unlock();
-    // we do a global sync here
-    interrupted = !MultiIface::sync->run(SyncTrigger::periodic, scheduledAt);
-    // Global sync completed or got interrupted.
-    // we are expected to exit with the eventq lock held
-    curEventQueue()->lock();
-    // schedule the next global sync event if this one completed. Otherwise
-    // (i.e. this one was interrupted by a checkpoint request), we will 
-    // reschedule this one after the draining is complete.
-    if (!interrupted)
-        schedule(scheduledAt + repeat);
+    {
+        EventQueue::ScopedRelease sr(curEventQueue());
+        // we do a global sync here that is supposed to happen at the same
+        // tick in all gem5 peers
+        MultiIface::sync->run(true);
+        // global sync completed
+    }
+    if (MultiIface::sync->doCkpt)
+        exitSimLoop("checkpoint");
+    if (MultiIface::sync->doExit)
+        exitSimLoop("exit request from gem5 peers");
+
+    // schedule the next periodic sync
+    repeat = MultiIface::sync->nextRepeat;
+    schedule(curTick() + repeat);
 }
 
-void MultiIface::SyncEvent::resume()
+void
+MultiIface::RecvScheduler::init(Event *recv_done, Tick link_delay)
 {
-    Tick sync_tick;
-    assert(!scheduled());
-    if (interrupted) {
-        assert(curTick() >= scheduledAt);
-        // We have to complete the interrupted periodic sync asap.
-        // Note that this sync might be interrupted now again with a checkpoint
-        // request from a peer gem5...
-        sync_tick = curTick();
-        schedule(sync_tick);
-    } else {
-        // So we completed the last periodic sync, let's find  out the tick for
-        // next one
-        assert(curTick() > scheduledAt);
-        sync_tick = scheduledAt + repeat;
-        if (sync_tick < curTick())
-            panic("Cannot resume periodic synchronisation");
-        schedule(sync_tick);
-    }
-    DPRINTF(MultiEthernet,
-            "MultiIface::SyncEvent periodic sync resumed at %lld "
-            "(curTick:%lld)\n", sync_tick, curTick());
+    // This is called from the receiver thread when it starts running. The new
+    // receiver thread shares the event queue with the simulation thread
+    // (associated with the simulated Ethernet link).
+    curEventQueue(eventManager->eventQueue());
+
+    recvDone = recv_done;
+    linkDelay = link_delay;
 }
 
-void MultiIface::SyncEvent::serialize(const std::string &base,
-                                      CheckpointOut &cp) const
+Tick
+MultiIface::RecvScheduler::calcReceiveTick(Tick send_tick,
+                                           Tick send_delay,
+                                           Tick prev_recv_tick,
+                                           unsigned source_rank)
 {
-    // Save the periodic multi sync schedule information
-    paramOut(cp, base + ".periodicSyncRepeat", repeat);
-    paramOut(cp, base + ".periodicSyncInterrupted", interrupted);
-    paramOut(cp, base + ".periodicSyncAt", scheduledAt);
+    Tick recv_tick = send_tick + send_delay + linkDelay;
+    // Adjust the receive tick if we do not have a big enough receive window.
+    // This gives us a very raw simulation of (receive) link contention.
+    if (prev_recv_tick + send_delay > recv_tick) {
+        DPRINTF(MultiEthernetPkt, "MultiIface::caclReceiveTick() "
+                "recv_tick %lu adjusted to %lu (prev_recv_tick: %lu "
+                "send_delay: %lu)\n",
+                recv_tick, prev_recv_tick + send_delay, prev_recv_tick,
+                send_delay);
+        recv_tick = prev_recv_tick + send_delay;
+    }
+    if (recv_tick <= curTick()) {
+        panic("Simulators out of sync - missed packet receive by %llu ticks"
+              "(rev_recv_tick: %lu send_tick: %lu send_delay: %lu "
+              "linkDelay: %lu source_rank: %d)",
+              curTick() - recv_tick, prev_recv_tick, send_tick, send_delay,
+              linkDelay, source_rank);
+    }
+    return recv_tick;
 }
 
-void MultiIface::SyncEvent::unserialize(const std::string &base,
-                                        CheckpointIn &cp)
+void
+MultiIface::RecvScheduler::resumeRecvTicks()
 {
-    paramIn(cp, base + ".periodicSyncRepeat", repeat);
-    paramIn(cp, base + ".periodicSyncInterrupted", interrupted);
-    paramIn(cp, base + ".periodicSyncAt", scheduledAt);
+    // Schedule pending packets asap in case link speed/delay changed when
+    // resuming from the checkpoint.
+    // This may be done during unserialize except that curTick() is unknown.
+    std::vector<Desc> v;
+    while (!descQueue.empty()) {
+        Desc d = descQueue.top();
+        descQueue.pop();
+        d.sendTick = curTick();
+        d.sendDelay = d.packet->size(); // assume 1 tick/byte max link speed
+        v.push_back(d);
+    }
+
+    for (auto &d : v)
+        descQueue.push(d);
+
+    if (recvDone->scheduled()) {
+        assert(!descQueue.empty());
+        eventManager->reschedule(recvDone, curTick());
+    } else {
+        assert(descQueue.empty() && v.empty());
+    }
+}
+
+void
+MultiIface::RecvScheduler::pushPacket(EthPacketPtr new_packet,
+                                      Tick send_tick,
+                                      Tick send_delay,
+                                      unsigned source_rank)
+{
+    // Note : this is called from the receiver thread
+    curEventQueue()->lock();
+    Tick recv_tick = calcReceiveTick(send_tick, send_delay, prevRecvTick,
+        source_rank);
+
+    DPRINTF(MultiEthernetPkt, "MultiIface::recvScheduler::pushPacket "
+            "send_tick:%llu send_delay:%llu link_delay:%llu recv_tick:%llu\n",
+            send_tick, send_delay, linkDelay, recv_tick);
+    // Every packet must be sent and arrive in the same quantum
+    assert(send_tick > master->syncEvent->when() -
+           master->syncEvent->repeat);
+    // No packet may be scheduled for receive in the arrivel quantum
+    assert(send_tick + send_delay + linkDelay > master->syncEvent->when());
+
+    // Now we are about to schedule a recvDone event for the new data packet.
+    // We use the same recvDone object for all incoming data packets. Packet
+    // descriptors are saved in the ordered queue. The currently scheduled
+    // packet is always on the top of the queue.
+    // NOTE:  we use the event queue lock to protect the receive desc queue,
+    // too, which is accessed both by the receiver thread and the simulation
+    // thread.
+    descQueue.emplace(new_packet, send_tick, send_delay, source_rank);
+    if (descQueue.size() > 1) {
+        assert(recvDone->scheduled());
+        if (descQueue.top().packet == new_packet)
+            eventManager->reschedule(recvDone, recv_tick);
+    } else {
+        assert(!recvDone->scheduled());
+        eventManager->schedule(recvDone, recv_tick);
+    }
+    curEventQueue()->unlock();
+}
+
+EthPacketPtr
+MultiIface::RecvScheduler::popPacket()
+{
+    // Note : this is called from the simulation thread when a receive done
+    // event is being processed for the link. We assume that the thread holds
+    // the event queue queue lock when this is called!
+    EthPacketPtr next_packet = descQueue.top().packet;
+    descQueue.pop();
+
+    if (descQueue.size() > 0) {
+        Tick recv_tick = calcReceiveTick(descQueue.top().sendTick,
+                                         descQueue.top().sendDelay,
+                                         curTick(),
+                                         descQueue.top().sourceRank);
+        eventManager->schedule(recvDone, recv_tick);
+    }
+    prevRecvTick = curTick();
+    return next_packet;
+}
+
+void
+MultiIface::RecvScheduler::Desc::serialize(CheckpointOut &cp) const
+{
+        SERIALIZE_SCALAR(sendTick);
+        SERIALIZE_SCALAR(sendDelay);
+        SERIALIZE_SCALAR(sourceRank);
+        packet->serialize("rxPacket", cp);
+}
+
+void
+MultiIface::RecvScheduler::Desc::unserialize(CheckpointIn &cp)
+{
+        UNSERIALIZE_SCALAR(sendTick);
+        UNSERIALIZE_SCALAR(sendDelay);
+        UNSERIALIZE_SCALAR(sourceRank);
+        packet = std::make_shared<EthPacketData>(16384);
+        packet->unserialize("rxPacket", cp);
+}
+
+void
+MultiIface::RecvScheduler::serialize(CheckpointOut &cp) const
+{
+    SERIALIZE_SCALAR(prevRecvTick);
+    // serialize the receive desc queue
+    unsigned n_desc_queue = descQueue.size();
+    SERIALIZE_SCALAR(n_desc_queue);
+    for (int i = 0; i < n_desc_queue; i++) {
+        descQueue.impl().at(i).serializeSection(cp, csprintf("rxDesc_%d", i));
+    }
+}
+
+void
+MultiIface::RecvScheduler::unserialize(CheckpointIn &cp)
+{
+    assert(descQueue.size() == 0);
+    assert(recvDone->scheduled() == false);
+
+    UNSERIALIZE_SCALAR(prevRecvTick);
+    // unserialize the receive desc queue
+    unsigned n_desc_queue;
+    UNSERIALIZE_SCALAR(n_desc_queue);
+    for (int i = 0; i < n_desc_queue; i++) {
+        Desc recv_desc;
+        recv_desc.unserializeSection(cp, csprintf("rxDesc_%d", i));
+        descQueue.push(recv_desc);
+    }
 }
 
 MultiIface::MultiIface(unsigned multi_rank,
+                       unsigned multi_size,
                        Tick sync_start,
                        Tick sync_repeat,
                        EventManager *em) :
     syncStart(sync_start), syncRepeat(sync_repeat),
-    recvThread(nullptr), eventManager(em), recvDone(nullptr),
-    scheduledRecvPacket(nullptr), linkDelay(0), rank(multi_rank)
+    recvThread(nullptr), recvScheduler(em),
+    rank(multi_rank), size(multi_size)
 {
     DPRINTF(MultiEthernet, "MultiIface() ctor rank:%d\n",multi_rank);
+    MultiHeaderPkt::clearAddress(networkAddress);
     if (master == nullptr) {
         assert(sync == nullptr);
         assert(syncEvent == nullptr);
@@ -336,43 +434,50 @@
         delete syncEvent;
         assert(sync);
         delete sync;
+        master = nullptr;
     }
 }
 
 void
 MultiIface::packetOut(EthPacketPtr pkt, Tick send_delay)
 {
-    MultiHeaderPkt::Header header_pkt;
+    Header header;
     unsigned address_length = MultiHeaderPkt::maxAddressLength();
 
     // Prepare a multi header packet for the Ethernet packet we want to
     // send out.
-    header_pkt.msgType = MsgType::dataDescriptor;
-    header_pkt.sendTick  = curTick();
-    header_pkt.sendDelay = send_delay;
+    header.msgType = MsgType::dataDescriptor;
+    header.sendTick  = curTick();
+    header.sendDelay = send_delay;
+    header.senderRank = rank;
 
     // Store also the source and destination addresses.
-    pkt->packAddress(header_pkt.srcAddress, header_pkt.dstAddress,
+    pkt->packAddress(header.srcAddress, header.dstAddress,
                      address_length);
 
-    header_pkt.dataPacketLength = pkt->size();
+    header.dataPacketLength = pkt->size();
 
-    // Send out the multi hedare packet followed by the Ethernet packet.
-    sendRaw(&header_pkt, sizeof(header_pkt), header_pkt.dstAddress);
-    sendRaw(pkt->data, pkt->size(), header_pkt.dstAddress);
+    // update our network address
+    if (!MultiHeaderPkt::isAddressEqual(header.srcAddress, networkAddress))
+        MultiHeaderPkt::copyAddress(networkAddress, header.srcAddress);
+
+    // Send out the packet and the meta info.
+    sendPacket(header, pkt);
+
     DPRINTF(MultiEthernetPkt,
             "MultiIface::sendDataPacket() done size:%d send_delay:%llu "
             "src:0x%02x%02x%02x%02x%02x%02x "
             "dst:0x%02x%02x%02x%02x%02x%02x\n",
             pkt->size(), send_delay,
-            header_pkt.srcAddress[0], header_pkt.srcAddress[1],
-            header_pkt.srcAddress[2], header_pkt.srcAddress[3],
-            header_pkt.srcAddress[4], header_pkt.srcAddress[5],
-            header_pkt.dstAddress[0], header_pkt.dstAddress[1],
-            header_pkt.dstAddress[2], header_pkt.dstAddress[3],
-            header_pkt.dstAddress[4], header_pkt.dstAddress[5]);
+            header.srcAddress[0], header.srcAddress[1],
+            header.srcAddress[2], header.srcAddress[3],
+            header.srcAddress[4], header.srcAddress[5],
+            header.dstAddress[0], header.dstAddress[1],
+            header.dstAddress[2], header.dstAddress[3],
+            header.dstAddress[4], header.dstAddress[5]);
 }
 
+/*
 bool
 MultiIface::recvHeader(MultiHeaderPkt::Header &header_pkt)
 {
@@ -387,116 +492,73 @@
     // that an Ethernet (data) packet is coming in next.
     assert(header_pkt.msgType == MsgType::dataDescriptor);
     // Allocate storage for the incoming Ethernet packet.
-    EthPacketPtr new_packet(new EthPacketData(header_pkt.dataPacketLength));
+    //EthPacketPtr new_packet(new EthPacketData(header_pkt.dataPacketLength));
+    EthPacketPtr new_packet  = std::make_shared<EthPacketData>(header_pkt.dataPacketLength);
     // Now execute the blocking receive and store the incoming data directly
     // in the new EthPacketData object.
     if (! recvRaw((void *)(new_packet->data), header_pkt.dataPacketLength))
         panic("Missing data packet");
 
     new_packet->length = header_pkt.dataPacketLength;
-    // Grab the event queue lock to schedule a new receive event for the
-    // data packet.
-    curEventQueue()->lock();
-    // Compute the receive tick. It includes the send delay and the
-    // simulated link delay.
-    Tick recv_tick = header_pkt.sendTick + header_pkt.sendDelay + linkDelay;
-    DPRINTF(MultiEthernetPkt, "MultiIface::recvThread() packet receive, "
-            "send_tick:%llu send_delay:%llu link_delay:%llu recv_tick:%llu\n",
-            header_pkt.sendTick, header_pkt.sendDelay, linkDelay, recv_tick);
 
-    if (recv_tick <= curTick()) {
-        panic("Simulators out of sync - missed packet receive by %llu ticks",
-              curTick() - recv_tick);
-    }
-    // Now we are about to schedule a recvDone event for the new data packet.
-    // We use the same recvDone object for all incoming data packets. If
-    // that is already scheduled - i.e. a receive event for a previous
-    // data packet is already pending - then we have to check whether the
-    // receive tick for the new packet is earlier than that of the currently
-    // pending event. Packets may arrive out-of-order with respect to
-    // simulated receive time. If that is the case, we need to re-schedule the
-    // recvDone event for the new packet. Otherwise, we save the packet
-    // pointer and the recv tick for the new packet in the recvQueue. See
-    // the implementation of the packetIn() method for comments on how this
-    // information is retrieved from the recvQueue by the simulation thread.
-    if (!recvDone->scheduled()) {
-        assert(recvQueue.size() == 0);
-        assert(scheduledRecvPacket == nullptr);
-        scheduledRecvPacket = new_packet;
-        eventManager->schedule(recvDone, recv_tick);
-    } else if (recvDone->when() > recv_tick) {
-        recvQueue.emplace(scheduledRecvPacket, recvDone->when());
-        eventManager->reschedule(recvDone, recv_tick);
-        scheduledRecvPacket = new_packet;
-    } else {
-        recvQueue.emplace(new_packet, recv_tick);
-    }
-    curEventQueue()->unlock();
+    // Schedule a new receive event for the data packet.
+    recvScheduler.pushPacket(new_packet,
+                             header_pkt.sendTick,
+                             header_pkt.sendDelay,
+                             header_pkt.senderRank);
+
 }
+*/
 
 void
-MultiIface::recvThreadFunc()
+MultiIface::recvThreadFunc(Event *recv_done, Tick link_delay)
 {
     EthPacketPtr new_packet;
     MultiHeaderPkt::Header header;
 
-    // The new receiver thread shares the event queue with the simulation
-    // thread (associated with the simulated Ethernet link).
-    curEventQueue(eventManager->eventQueue());
+    // Initialize receive scheduler parameters
+    recvScheduler.init(recv_done, link_delay);
+
     // Main loop to wait for and process any incoming message.
     for (;;) {
         // recvHeader() blocks until the next multi header packet comes in.
         if (!recvHeader(header)) {
             // We lost connection to the peer gem5 processes most likely
             // because one of them called m5 exit. So we stop here.
-            exit_message("info", 0, "Message server closed connection, "
+            // Grab the eventq lock to stop the simulation thread
+            curEventQueue()->lock();
+            exit_message("info",
+                         0,
+                         "Message server closed connection, "
                          "simulation is exiting");
         }
         // We got a valid multi header packet, let's process it
         if (header.msgType == MsgType::dataDescriptor) {
-            recvData(header);
+            recvPacket(header, new_packet);
+            recvScheduler.pushPacket(new_packet,
+                                     header.sendTick,
+                                     header.sendDelay,
+                                     header.senderRank);
         } else {
+            assert(header.msgType == MsgType::cmdSyncAck);
             // everything else must be synchronisation related command
-            sync->progress(header.msgType);
+            sync->progress(header.maxSyncReqTick,
+                           header.syncRepeat,
+                           header.doCkpt,
+                           header.doExit);
         }
     }
 }
 
-EthPacketPtr
-MultiIface::packetIn()
-{
-    // We are called within the process() method of the recvDone event. We
-    // return the packet that triggered the current receive event.
-    // If there is further packets in the recvQueue, we also have to schedule
-    // the recvEvent for the next packet with the smallest receive tick.
-    // The priority queue container ensures that smallest receive tick is
-    // always on the top of the queue.
-    assert(scheduledRecvPacket != nullptr);
-    EthPacketPtr next_packet = scheduledRecvPacket;
-
-    if (! recvQueue.empty()) {
-        eventManager->schedule(recvDone, recvQueue.top().second);
-        scheduledRecvPacket = recvQueue.top().first;
-        recvQueue.pop();
-    } else {
-        scheduledRecvPacket = nullptr;
-    }
-
-    return next_packet;
-}
-
 void
 MultiIface::spawnRecvThread(Event *recv_done, Tick link_delay)
 {
     assert(recvThread == nullptr);
-    // all receive thread must be spawned before simulation starts
-    assert(eventManager->eventQueue()->getCurTick() == 0);
 
-    recvDone = recv_done;
-    linkDelay = link_delay;
-
-    recvThread = new std::thread(&MultiIface::recvThreadFunc, this);
-
+    recvThread = new std::thread(&MultiIface::recvThreadFunc,
+                                 this,
+                                 recv_done,
+                                 link_delay);
     recvThreadsNum++;
 }
 
@@ -507,86 +569,54 @@
 
     // This can be called multiple times in the same drain cycle.
     if (master == this) {
-        syncEvent->isDraining = true;
+        sync->drainStart();
     }
 
     return DrainState::Drained;
 }
 
-void MultiIface::drainDone() {
+void
+MultiIface::drainResume() {
     if (master == this) {
-        assert(syncEvent->isDraining == true);
-        syncEvent->isDraining = false;
-        // We need to resume the interrupted periodic sync here now that the
-        // draining is done. If the last periodic sync completed before the
-        // checkpoint then the next one is already scheduled.
-        if (syncEvent->interrupted)
-            syncEvent->resume();
+        syncEvent->start();
     }
+    recvScheduler.resumeRecvTicks();
 }
 
-void MultiIface::serialize(const std::string &base, CheckpointOut &cp) const
+void
+MultiIface::serialize(CheckpointOut &cp) const
 {
     // Drain the multi interface before the checkpoint is taken. We cannot call
     // this as part of the normal drain cycle because this multi sync has to be
     // called exactly once after the system is fully drained.
-    // Note that every peer will take a checkpoint but they may take it at
-    // different ticks.
-    // This sync request may interrupt an on-going periodic sync in some peers.
-    sync->run(SyncTrigger::ckpt, curTick());
+    sync->drainComplete();
 
-    // Save the periodic multi sync status
-    syncEvent->serialize(base, cp);
-
-    unsigned n_rx_packets = recvQueue.size();
-    if (scheduledRecvPacket != nullptr)
-        n_rx_packets++;
-
-    paramOut(cp, base + ".nRxPackets", n_rx_packets);
-
-    if (n_rx_packets > 0) {
-        assert(recvDone->scheduled());
-        scheduledRecvPacket->serialize(base + ".rxPacket[0]", cp);
-    }
-
-    for (unsigned i=1; i < n_rx_packets; i++)  {
-        const RecvInfo recv_info = recvQueue.impl().at(i-1);
-        recv_info.first->serialize(base + csprintf(".rxPacket[%d]", i), cp);
-        Tick rx_tick = recv_info.second;
-        paramOut(cp, base + csprintf(".rxTick[%d]", i), rx_tick);
+    SERIALIZE_ARRAY(networkAddress, sizeof(networkAddress));
+    recvScheduler.serializeSection(cp, "recvScheduler");
+    if (this == master) {
+        sync->serializeSection(cp, "Sync");
     }
 }
 
-void MultiIface::unserialize(const std::string &base, CheckpointIn &cp)
+void
+MultiIface::unserialize(CheckpointIn &cp)
 {
-    assert(recvQueue.size() == 0);
-    assert(scheduledRecvPacket == nullptr);
-    assert(recvDone->scheduled() == false);
-
-    // restore periodic sync info
-    syncEvent->unserialize(base, cp);
-
-    unsigned n_rx_packets;
-    paramIn(cp, base + ".nRxPackets", n_rx_packets);
-
-    if (n_rx_packets > 0) {
-        scheduledRecvPacket = std::make_shared<EthPacketData>(16384);
-        scheduledRecvPacket->unserialize(base + ".rxPacket[0]", cp);
-        // Note: receive event will be scheduled when the link is unserialized
-    }
-
-    for (unsigned i=1; i < n_rx_packets; i++) {
-        EthPacketPtr rx_packet = std::make_shared<EthPacketData>(16384);
-        rx_packet->unserialize(base + csprintf(".rxPacket[%d]", i), cp);
-        Tick rx_tick = 0;
-        paramIn(cp, base + csprintf(".rxTick[%d]", i), rx_tick);
-        assert(rx_tick > 0);
-        recvQueue.emplace(rx_packet,rx_tick);
-    }
+    UNSERIALIZE_ARRAY(networkAddress, sizeof(networkAddress));
+    recvScheduler.unserializeSection(cp, "recvScheduler");
+    if (this == master) {
+        sync->unserializeSection(cp, "Sync");
+  }
 }
 
-void MultiIface::initRandom()
+void
+MultiIface::init()
 {
+    // Adjust the periodic sync start and interval. Different MultiIface
+    // might have different requirements. The singleton sync object
+    // will select the minimum values for both params.
+    assert(sync != nullptr);
+    sync->init(syncStart, syncRepeat);
+
     // Initialize the seed for random generator to avoid the same sequence
     // in all gem5 peer processes
     assert(master != nullptr);
@@ -594,29 +624,76 @@
         random_mt.init(5489 * (rank+1) + 257);
 }
 
-void MultiIface::startPeriodicSync()
+void
+MultiIface::startup()
 {
-    DPRINTF(MultiEthernet, "MultiIface:::initPeriodicSync started\n");
-    // Do a global sync here to ensure that peer gem5 processes are around
-    // (actually this may not be needed...)
-    sync->run(SyncTrigger::atomic, curTick());
+    DPRINTF(MultiEthernet, "MultiIface::startup() started\n");
+    // Now that everything is up-to-date give the underlying messaging system
+    // a chance to access any information (e.g. networkAddress restored from
+    // a checkpoint)
+    initTransport();
 
-    // Start the periodic sync if it is a fresh simulation from scratch
-    if (curTick() == 0) {
-        if (this == master) {
-        syncEvent->start(syncStart, syncRepeat);
-        inform("Multi synchronisation activated: start at %lld, "
-               "repeat at every %lld ticks.\n",
-               syncStart, syncRepeat);
-        } else {
-            // In case another multiIface object requires different schedule
-            // for periodic sync than the master does.
-            syncEvent->adjust(syncStart, syncRepeat);
-        }
+    // If this run is a resume from a checkpoint than we schedule the first
+    // periodic sync in drainResume()
+    if (curTick() == 0 && this == master)
+        syncEvent->start();
+
+    DPRINTF(MultiEthernet, "MultiIface::startup() done\n");
+}
+
+bool
+MultiIface::readyToCkpt(Tick delay, Tick period)
+{
+    bool ret = true;
+    DPRINTF(MultiEthernet, "MultiIface::readyToCkpt() called, delay:%lu "
+            "period:%lu\n", delay, period);
+    if (master) {
+        sync->requestCkpt();
+        ret = false;
+        if (delay != 0 || period != 0)
+            inform("Non zero delay or period for m5_ckpt is ignored in "
+                   "multi-gem5 mode\n");
+    }
+    return ret;
+}
+
+bool
+MultiIface::readyToExit(Tick delay)
+{
+    bool ret = true;
+    DPRINTF(MultiEthernet, "MultiIface::readyToExit() called, delay:%lu\n",
+            delay);
+    if (master) {
+        sync->requestExit();
+        ret = false;
+        if (delay != 0)
+            inform("Non zero delay for m5_exit is ignored in multi-gem5 mode\n");
+    }
+    return ret;
+}
+
+uint64_t
+MultiIface::rankParam()
+{
+    uint64_t val;
+    if (master) {
+        val = master->rank;
     } else {
-        // Schedule the next periodic sync if resuming from a checkpoint
-        if (this == master)
-            syncEvent->resume();
+        warn("Multi-rank parameter is queried in single gem5 simulation.");
+        val = 0;
     }
-    DPRINTF(MultiEthernet, "MultiIface::initPeriodicSync done\n");
+    return val;
 }
+
+uint64_t
+MultiIface::sizeParam()
+{
+    uint64_t val;
+    if (master) {
+        val = master->size;
+    } else {
+        warn("Multi-size parameter is queried in single gem5 simulation.");
+        val = 1;
+    }
+    return val;
+}
diff --git a/src/dev/multi_iface.hh b/src/dev/multi_iface.hh
--- a/src/dev/multi_iface.hh
+++ b/src/dev/multi_iface.hh
@@ -89,78 +89,34 @@
 #include "sim/core.hh"
 #include "sim/drain.hh"
 #include "sim/global_event.hh"
+#include "sim/serialize.hh"
 
 class EventManager;
 
 /**
  * The interface class to talk to peer gem5 processes.
  */
-class MultiIface : public Drainable
+class MultiIface : public Drainable, public Serializable
 {
   public:
-    /*!
-     * The possible reasons a multi sync among gem5 peers is needed for.
-     */
-    enum
-    class SyncTrigger {
-        periodic, /*!< Regular periodic sync. This can be interrupted by a
-                   checkpoint sync request */
-        ckpt,     /*!< sync before taking a checkpoint */
-        atomic    /*!< sync that cannot be interrupted (e.g. sync at startup) */
-    };
+    typedef MultiHeaderPkt::Header Header;
+
+  protected:
+    typedef MultiHeaderPkt::MsgType MsgType;
 
   private:
-    typedef MultiHeaderPkt::MsgType MsgType;
-
-    /** Sync State-Machine
-     \dot
-     digraph Sync {
-     node [shape=box, fontsize=10];
-     idle -> busy
-     [ label="new trigger\n by run()" fontsize=8 ];
-     busy -> busy
-     [ label="new message by progress():\n(msg == SyncAck &&\nwaitNum > 1) || \n(msg==CkptSyncReq &&\ntrigger == ckpt)" fontsize=8 ];
-     busy -> idle
-     [ label="new message by progress():\n(msg == SyncAck &&\nwaitNum == 1)" fontsize=8 ];
-     busy -> interrupted
-     [ label="new message by progress():\n(msg == CkptSyncReq &&\ntrigger == periodic)" fontsize=8 ];
-     idle -> asyncCkpt
-     [ label="new message by progress():\nmsg == CkptSyncReq" fontsize=8 ];
-     asyncCkpt -> asyncCkpt
-     [ label="new message by progress():\nmsg == CkptSyncReq" fontsize=8 ];
-     asyncCkpt -> busy
-     [ label="new trigger by run():\ntrigger == ckpt" fontsize=8 ];
-     asyncCkpt -> idle
-     [ label="new trigger by run():\n(trigger == periodic &&\nwaitNum == 0) " fontsize=8 ];
-     asyncCkpt -> interrupted
-     [ label="new trigger by run():\n(trigger == periodic &&\nwaitNum > 0) " fontsize=8 ];
-     interrupted -> interrupted
-     [ label="new message by progress():\n(msg == CkptSyncReq &&\nwaitNum > 1)" fontsize=8 ];
-     interrupted -> idle
-     [ label="new message by progress():\n(msg == CkptSyncReq &&\nwaitNum == 1)" fontsize=8 ];
-     }
-     \enddot
-     */
+    class SyncEvent;
     /** @class Sync
      * This class implements global sync operations among gem5 peer processes.
      *
      * @note This class is used as a singleton object (shared by all MultiIface
      * objects).
      */
-    class Sync
+    class Sync : public Serializable
     {
       private:
-        /*!
-         * Internal state of the sync singleton object.
-         */
-        enum class SyncState {
-            busy,        /*!< There is an on-going sync. */
-            interrupted, /*!< An on-going periodic sync was interrupted. */
-            asyncCkpt,   /*!< A checkpoint (sim_exit) is already scheduled */
-            idle         /*!< There is no active sync. */
-        };
         /**
-         * The lock to protect access to the MultiSync object.
+         * The lock to protect access to the Sync object.
          */
         std::mutex lock;
         /**
@@ -175,42 +131,73 @@
          */
         unsigned waitNum;
         /**
-         * The trigger for the most recent sync.
+         * Flag is set if m5_exit pseudo instruction encountered
          */
-        SyncTrigger trigger;
+        bool needExit;
         /**
-         * Map sync triggers to request messages.
+         * Flag is set if m5_ckpt pseudo instruction encountered
          */
-        std::array<MsgType, 3> triggerToMsg = {{
-                MsgType::cmdPeriodicSyncReq,
-                MsgType::cmdCkptSyncReq,
-                MsgType::cmdAtomicSyncReq
-            }};
+        bool needCkpt;
+        /**
+         * Flag is set if exit is permitted upon sync completion
+         */
+        bool doExit;
+        /**
+         * Flag is set if taking a ckpt is permitted upon sync completion
+         */
+        bool doCkpt;
+        /**
+         * Flag is set if the sync before taking a ckpt is done.
+         */
+        bool isCkptSyncDone;
+        /**
+         * Tick for the next periodic sync (if the event is not scheduled yet)
+         */
+        Tick nextAt;
+        /**
+         * The repeat value for the next periodic sync
+         */
+        Tick nextRepeat;
 
-        /**
-         * Current sync state.
-         */
-        SyncState state;
+        friend class SyncEvent;
 
       public:
         /**
+         * Initialize periodic sync params.
+         *
+         * @param start Start tick for multi synchronisation
+         * @param repeat Frequency of multi synchronisation
+         *
+         */
+        void init(Tick  start, Tick repeat);
+        /**
          *  Core method to perform a full multi sync.
-         *
-         * @param t Sync trigger.
-         * @param sync_tick The tick the sync was expected to happen at.
-         * @return true if the sync completed, false if it was interrupted.
-         *
-         * @note In case of an interrupted periodic sync, sync_tick can be less
-         * than curTick() when we resume (i.e. re-run) it
          */
-        bool run(SyncTrigger t, Tick sync_tick);
+        void run(bool same_tick);
         /**
-         * Callback when the receiver thread gets a sync message.
+         * Callback when the receiver thread gets a sync ack message.
          */
-        void progress(MsgType m);
+        void progress(Tick max_req_tick,
+                      Tick next_repeat,
+                      bool do_ckpt,
+                      bool do_exit);
 
-        Sync() : waitNum(0), state(SyncState::idle) {}
+
+        Sync() : waitNum(0), needExit(false), needCkpt(false),
+                 doExit(false), doCkpt(false),
+                 nextAt(std::numeric_limits<Tick>::max()),
+                 nextRepeat(std::numeric_limits<Tick>::max()) {}
         ~Sync() {}
+
+        void requestCkpt();
+        void requestExit();
+
+        void drainStart() { isCkptSyncDone = false; }
+        void drainComplete();
+
+        void serialize(CheckpointOut &cp) const M5_ATTR_OVERRIDE;
+        void unserialize(CheckpointIn &cp) M5_ATTR_OVERRIDE;
+
     };
 
 
@@ -230,106 +217,184 @@
     {
       public:
         /**
-         * Flag to indicate that the most recent periodic sync was interrupted
-         * (by a checkpoint request).
-         */
-        bool interrupted;
-        /**
-         * The tick when the most recent periodic synchronisation was scheduled
-         * at.
-         */
-        Tick scheduledAt;
-        /**
-         * Flag to indicate an on-going drain cycle.
-         */
-         bool isDraining;
-
-      public:
-        /**
-         * Only the firstly instanstiated MultiIface object will
+         * Only the firstly instantiated MultiIface object will
          * call this constructor.
          */
-        SyncEvent() : GlobalSyncEvent(Default_Pri, 0), interrupted(false),
-                      scheduledAt(0), isDraining(false) {}
+        SyncEvent() : GlobalSyncEvent(Sim_Exit_Pri, 0) {}
 
-        ~SyncEvent() { assert (scheduled() == false); }
+        ~SyncEvent() {}
         /**
          * Schedule the first periodic sync event.
-         *
-         * @param start Start tick for multi synchronisation
-         * @param repeat Frequency of multi synchronisation
-         *
          */
-        void start(Tick start, Tick repeat);
-        /**
-         * Reschedule (if necessary) the periodic sync event.
-         *
-         * @param start Start tick for multi synchronisation
-         * @param repeat Frequency of multi synchronisation
-         *
-         * @note Useful if we have multiple MultiIface objects with
-         * different 'start' and 'repeat' values for global sync.
-         */
-        void adjust(Tick start, Tick repeat);
+        void start();
         /**
          * This is a global event so process() will be called by each
          * simulation threads. (See further comments in the .cc file.)
          */
         void process() M5_ATTR_OVERRIDE;
+    };
+    /**
+     * Class to encapsulate information about data packets received.
+
+     * @note The main purpose of the class to take care of scheduling receive
+     * done events for the simulated network link and store incoming packets
+     * until they can be received by the simulated network link.
+     */
+    class RecvScheduler : public Serializable
+    {
+      private:
         /**
-         * Schedule periodic sync when resuming from a checkpoint.
+         * Received packet descriptor. This information is used by the receive
+         * thread to schedule receive events and by the simulation thread to
+         * process those events.
          */
-        void resume();
+        struct Desc : public Serializable {
+            EthPacketPtr packet;
+            Tick sendTick;
+            Tick sendDelay;
+            int sourceRank;
 
-        void serialize(const std::string &base, CheckpointOut &cp) const;
-        void unserialize(const std::string &base, CheckpointIn &cp);
-    };
+            Desc() : sendTick(0), sendDelay(0), sourceRank(-1) {}
+            Desc(EthPacketPtr p, Tick s, Tick d, int r) :
+                packet(p), sendTick(s), sendDelay(d), sourceRank(r) {}
+            Desc(const Desc &d) :
+                packet(d.packet), sendTick(d.sendTick), sendDelay(d.sendDelay),
+                sourceRank(d.sourceRank) {}
 
-    /**
-     * The receive thread needs to store the packet pointer and the computed
-     * receive tick for each incoming data packet. This information is used
-     * by the simulation thread when it processes the corresponding receive
-     * event. (See more comments at the implemetation of the recvThreadFunc()
-     * and RecvPacketIn() methods.)
-     */
-    typedef std::pair<EthPacketPtr, Tick> RecvInfo;
+            void serialize(CheckpointOut &cp) const M5_ATTR_OVERRIDE;
+            void unserialize(CheckpointIn &cp) M5_ATTR_OVERRIDE;
+        };
+        /**
+         * Comparison predicate for receive descriptors.
+         *
+         * @note Receive descriptors are stored in the ordered receive queue.
+         * The primary key for ordering is the send_tick+send_delay, the
+         * secondary is the rank of the sender. We use the secondary key to
+         * ensure reproducibility across multi-node gem5 runs (i.e. the ordering
+         * of the incoming packets are always well defined in the receive
+         * queue).
+         * It would be simpler to store the calculated receive tick in the
+         * descriptors and use that as primary key but unfortunately the
+         * receive tick may change as new packets are coming in out of order
+         * (and we have to maintain a big enough receive window, see
+         * calcReceiveTick() method).
+         */
+        struct DescCompare {
+            bool operator()(const Desc &lhs, const Desc &rhs)
+            {
+                Tick lhs_key = lhs.sendTick + lhs.sendDelay;
+                Tick rhs_key = rhs.sendTick + rhs.sendDelay;
+                return ((lhs_key > rhs_key) ||
+                        (lhs_key == rhs_key && lhs.sourceRank > rhs.sourceRank));
+            }
+        };
+        /**
+         * Customized priority queue used to store incoming data packets
+         * descriptors by the receiver thread. We need to expose the underlying
+         * container to enable iterator access for serializing.
+         */
+        class DescQueue : public std::priority_queue<Desc,
+                                                     std::vector<Desc>,
+                                                     DescCompare>
+        {
+          public:
+            std::vector<Desc> &impl() { return c; }
+            const std::vector<Desc> &impl() const { return c; }
+        };
+        /**
+         * The priority queue to store the receive descriptors.
+         */
+        DescQueue descQueue;
+        /**
+         * The tick when the most recent receive event was processed.
+         *
+         * @note This information is necessary to simulate possible receiver
+         * link contention when calculating the receive tick for the next
+         * incoming data packet (see the calcReceiveTick() method)
+         */
+        Tick prevRecvTick;
+        /**
+         * The receive done event for the simulated Ethernet link.
+         *
+         * @note This object is constructed by the simulated network link. We
+         * schedule this object for each incoming data packet.
+         */
+        Event *recvDone;
+        /**
+         * The link delay in ticks for the simulated Ethernet link.
+         *
+         * @note This value is used for calculating the receive ticks for an
+         * incoming data packets.
+         */
+        Tick linkDelay;
+        /**
+         * The event manager associated with the simulated Ethernet link.
+         *
+         * @note It is used to access the event queue for scheduling receive
+         * done events for the link.
+         */
+        EventManager *eventManager;
+        /**
+         * Calculate the tick to schedule the next receive done event.
+         *
+         * @param send_tick The tick the packet was sent.
+         * @param send_delay The simulated delay at the sender side.
+         * @param prev_recv_tick Tick when the last receive event was
+         * processed.
+         *
+         * @note This method tries to take into account possible receiver link
+         * contention and adjust receive tick for the incoming packets
+         * accordingly.
+         */
+        Tick calcReceiveTick(Tick send_tick,
+                             Tick send_delay,
+                             Tick prev_recv_tick,
+                             unsigned source_rank);
 
-    /**
-     * Comparison predicate for RecvInfo, needed by the recvQueue.
-     */
-    struct RecvInfoCompare {
-        bool operator()(const RecvInfo &lhs, const RecvInfo &rhs)
-        {
-            return lhs.second > rhs.second;
-        }
-    };
+      public:
+        /**
+         * Scheduler for the incoming data packets.
+         *
+         * @param em The event manager associated with the simulated Ethernet
+         * link.
+         */
+        RecvScheduler(EventManager *em) :
+            prevRecvTick(0), recvDone(nullptr), linkDelay(0),
+            eventManager(em) {}
 
-    /**
-     * Customized priority queue used to store incoming data packets info by
-     * the receiver thread. We need to expose the underlying container to
-     * enable iterator access for serializing.
-     */
-    class RecvQueue : public std::priority_queue<RecvInfo,
-                                                 std::vector<RecvInfo>,
-                                                 RecvInfoCompare>
-    {
-      public:
-        std::vector<RecvInfo> &impl() { return c; }
-        const std::vector<RecvInfo> &impl() const { return c; }
-    };
+        /**
+         *  Initialize network link parameters.
+         *
+         * @note This method is called from the receiver thread (see
+         * recvThreadFunc()).
+         */
+        void init(Event *recv_done, Tick link_delay);
+        /**
+         * Fetch the next packet that is to be received by the simulated network
+         * link.
+         *
+         * @note This method is called from the process() method of the receive
+         * done event associated with the network link.
+         */
+        EthPacketPtr popPacket();
+        /**
+         * Push a newly arrived packet into the desc queue.
+         */
+        void pushPacket(EthPacketPtr new_packet,
+                        Tick send_tick,
+                        Tick send_delay,
+                        unsigned source_rank);
 
-    /*
-     * The priority queue to store RecvInfo items ordered by receive ticks.
-     */
-    RecvQueue recvQueue;
-    /**
-     * The singleton Sync object to perform multi synchronisation.
-     */
-    static Sync *sync;
-    /**
-     * The singleton SyncEvent object to schedule periodic multi sync.
-     */
-    static SyncEvent *syncEvent;
+        void serialize(CheckpointOut &cp) const M5_ATTR_OVERRIDE;
+        void unserialize(CheckpointIn &cp) M5_ATTR_OVERRIDE;
+        /**
+         * Adjust receive ticks for pending packets when resuming from a
+         * checkpoint
+         *
+         * @note Link speed and delay parameters may change at resume.
+         */
+        void resumeRecvTicks();
+  };
     /**
      * Tick to schedule the first multi sync event.
      * This is just as optimization : we do not need any multi sync
@@ -346,31 +411,26 @@
      */
     std::thread *recvThread;
     /**
-     * The event manager associated with the MultiIface object.
+     * Meta information about data packets received.
      */
-    EventManager *eventManager;
+    RecvScheduler recvScheduler;
 
-    /**
-     * The receive done event for the simulated Ethernet link.
-     * It is scheduled by the receiver thread for each incoming data
-     * packet.
-     */
-    Event *recvDone;
-
-    /**
-     * The packet that belongs to the currently scheduled recvDone event.
-     */
-    EthPacketPtr scheduledRecvPacket;
-
-    /**
-     * The link delay in ticks for the simulated Ethernet link.
-     */
-    Tick linkDelay;
-
+  protected:
     /**
      * The rank of this process among the gem5 peers.
      */
     unsigned rank;
+
+    /**
+     * The number of gem5 processes comprising this multi simulation.
+     */
+    unsigned size;
+    /**
+     * The network address of the associated link.
+     */
+    MultiHeaderPkt::AddressType networkAddress;
+
+  private:
     /**
      * Total number of receiver threads (in this gem5 process).
      * During the simulation it should be constant and equal to the
@@ -379,57 +439,58 @@
      */
     static unsigned recvThreadsNum;
     /**
+     * The singleton Sync object to perform multi synchronisation.
+     */
+    static Sync *sync;
+    /**
+     * The singleton SyncEvent object to schedule periodic multi sync.
+     */
+    static SyncEvent *syncEvent;
+    /**
      * The very first MultiIface object created becomes the master. We need
      * a master to co-ordinate the global synchronisation.
      */
     static MultiIface *master;
 
-  protected:
+  private:
     /**
-     * Low level generic send routine.
-     * @param buf buffer that holds the data to send out
-     * @param length number of bytes to send
-     * @param dest_addr address of the target (simulated NIC). This may be
-     * used by a subclass for optimization (e.g. optimize broadcast)
+     * Send out a data packet to the remote end.
+     * @param header Meta info about the packet (which needs to be transferred
+     * to the destination alongside the packet).
+     * @param packet Pointer to the packet to send.
      */
-    virtual void sendRaw(void *buf,
-                         unsigned length,
-                         const MultiHeaderPkt::AddressType dest_addr) = 0;
+    virtual void sendPacket(const Header &header, const EthPacketPtr &packet) = 0;
     /**
-     * Low level generic receive routine.
-     * @param buf the buffer to store the incoming message
-     * @param length buffer size (in bytes)
+     * Send out a control command to the remote end.
+     * @param header Meta info describing the command (e.g. sync request)
      */
-    virtual bool recvRaw(void *buf, unsigned length) = 0;
+    virtual void sendCmd(const Header &header) = 0;
     /**
-     * Low level request for synchronisation among gem5 processes. Only one
-     * MultiIface object needs to call this (in each gem5 process) to trigger
-     * a multi sync.
-     *
-     * @param sync_req Sync request command.
-     * @param sync_tick The tick when sync is expected to happen in the sender.
+     * Receive a header (i.e. meta info describing a data packet or a control command)
+     * from the remote end.
+     * @param header The meta info structure to store the incoming header.
      */
-    virtual void syncRaw(MsgType sync_req, Tick sync_tick) = 0;
+    virtual bool recvHeader(Header &header) = 0;
+    /**
+     * Receive a packet from the remote end.
+     * @param header Meta info about the incoming packet (obtanied by a previous
+     * call to the recvHedaer() method).
+     * @param Pointer to packet received.
+     */
+    virtual void recvPacket(const Header &header, EthPacketPtr &packet) = 0;
+    /**
+     * Initialize hook for the underlying messaging system.
+
+     * @note This method must be called during startup(). It gives the
+     * underlying messaging system a chance to access up-to-date information
+     * from the base class before the simulation starts (e.g. networkAddress
+     * restored from a checkpoint).
+     */
+    virtual void initTransport() = 0;
     /**
      * The function executed by a receiver thread.
      */
-    void recvThreadFunc();
-    /**
-     * Receive a multi header packet. Called by the receiver thread.
-     * @param header the structure to store the incoming header packet.
-     * @return false if any error occured during the receive, true otherwise
-     *
-     * A header packet can carry a control command (e.g. 'barrier leave') or
-     * information about a data packet that is following the header packet
-     * back to back.
-     */
-    bool recvHeader(MultiHeaderPkt::Header &header);
-    /**
-     * Receive a data packet. Called by the receiver thread.
-     * @param data_header The packet descriptor for the expected incoming data
-     * packet.
-     */
-    void recvData(const MultiHeaderPkt::Header &data_header);
+    void recvThreadFunc(Event *recv_done, Tick link_delay);
 
   public:
 
@@ -441,6 +502,7 @@
      * @param em The event manager associated with the simulated Ethernet link
      */
     MultiIface(unsigned multi_rank,
+               unsigned multi_size,
                Tick sync_start,
                Tick sync_repeat,
                EventManager *em);
@@ -453,40 +515,51 @@
      */
     void packetOut(EthPacketPtr pkt, Tick send_delay);
     /**
-     * Fetch the next packet from the receive queue.
+     * Fetch the packet scheduled to be received next by the simulated
+     * network link.
+     *
+     * @note This method is called within the process() method of the link
+     * receive done event. It also schedules the next receive event if the
+     * receive queue is not empty.
      */
-    EthPacketPtr packetIn();
-
+    EthPacketPtr packetIn() { return recvScheduler.popPacket(); }
     /**
      * spawn the receiver thread.
      * @param recv_done The receive done event associated with the simulated
      * Ethernet link.
      * @param link_delay The link delay for the simulated Ethernet link.
      */
-    void spawnRecvThread(Event *recv_done,
-                         Tick link_delay);
-    /**
-     * Initialize the random number generator with a different seed in each
-     * peer gem5 process.
-     */
-    void initRandom();
+    void spawnRecvThread(Event *recv_done, Tick link_delay);
 
     DrainState drain() M5_ATTR_OVERRIDE;
+    void drainResume() M5_ATTR_OVERRIDE;
+    void init();
+    void startup();
 
+    void serialize(CheckpointOut &cp) const M5_ATTR_OVERRIDE;
+    void unserialize(CheckpointIn &cp) M5_ATTR_OVERRIDE;
     /**
-     * Callback when draining is complete.
+     * Initiate the exit from the simulation.
+     *
+     * @return False if we are in multi mode and a collaborative exit is
+     * initiated, True otherwise.
      */
-    void drainDone();
-
+    static bool readyToExit(Tick delay);
     /**
-     * Initialize the periodic synchronisation among peer gem5 processes.
+     * Initiate taking a checkpoint
+     *
+     * @return False if we are in multi mode and a collaborative checkpoint is
+     * initiated, True otherwise.
      */
-    void startPeriodicSync();
-
-    void serialize(const std::string &base, CheckpointOut &cp) const;
-    void unserialize(const std::string &base, CheckpointIn &cp);
-
-};
-
+    static bool readyToCkpt(Tick delay, Tick period);
+    /**
+     * Getter for the multi rank param.
+     */
+    static uint64_t rankParam();
+    /**
+     * Getter for the multi size param.
+     */
+    static uint64_t sizeParam();
+ };
 
 #endif
diff --git a/src/dev/multi_packet.hh b/src/dev/multi_packet.hh
--- a/src/dev/multi_packet.hh
+++ b/src/dev/multi_packet.hh
@@ -76,28 +76,42 @@
     enum class MsgType
     {
         dataDescriptor,
-        cmdPeriodicSyncReq,
-        cmdPeriodicSyncAck,
-        cmdCkptSyncReq,
-        cmdCkptSyncAck,
-        cmdAtomicSyncReq,
-        cmdAtomicSyncAck,
+        cmdSyncReq,
+        cmdSyncAck,
+        cmdCkptReq,
+        cmdExitReq,
         unknown
     };
 
     struct Header
     {
         /**
-         * The msg type field is valid for all header packets. In case of
-         * a synchronisation control command this is the only valid field.
+         * The msg type field is valid for all header packets.
+         *
+         * @note senderRank is used with data packets while collFlags are used
+         * by sync ack messages to trigger collective ckpt or exit events.
          */
         MsgType msgType;
-        Tick sendTick;
-        Tick sendDelay;
-        /**
-         * Actual length of the simulated Ethernet packet.
-         */
-        unsigned dataPacketLength;
+        union {
+            Tick sendTick;
+            Tick maxSyncReqTick;
+        };
+        union {
+            Tick sendDelay;
+            Tick syncRepeat;
+        };
+        union {
+            unsigned senderRank;
+            bool sameTick;
+            bool doCkpt;
+        };
+        union {
+            /**
+             * Actual length of the simulated Ethernet packet.
+             */
+            unsigned dataPacketLength;
+            bool doExit;
+        };
         /**
          * Source MAC address.
          */
diff --git a/src/dev/tcp_iface.cc b/src/dev/tcp_iface.cc
--- a/src/dev/tcp_iface.cc
+++ b/src/dev/tcp_iface.cc
@@ -54,6 +54,7 @@
 
 #include "base/types.hh"
 #include "debug/MultiEthernet.hh"
+#include "sim/sim_exit.hh"
 
 // MSG_NOSIGNAL does not exists on OS X
 #if defined(__APPLE__) || defined(__MACH__)
@@ -67,9 +68,10 @@
 vector<int> TCPIface::sockRegistry;
 
 TCPIface::TCPIface(string server_name, unsigned server_port,
-                   unsigned multi_rank, Tick sync_start, Tick sync_repeat,
+                   unsigned multi_rank, unsigned multi_size,
+                   Tick sync_start, Tick sync_repeat,
                    EventManager *em) :
-    MultiIface(multi_rank, sync_start, sync_repeat, em)
+    MultiIface(multi_rank, multi_size, sync_start, sync_repeat, em)
 {
     struct addrinfo addr_hint, *addr_results;
     int ret;
@@ -98,8 +100,6 @@
     freeaddrinfo(addr_results);
     // add our socket to the static registry
     sockRegistry.push_back(sock);
-    // let the server know who we are
-    sendTCP(sock, &multi_rank, sizeof(multi_rank));
 }
 
 TCPIface::~TCPIface()
@@ -111,12 +111,31 @@
 }
 
 void
-TCPIface::sendTCP(int sock, void *buf, unsigned length)
+TCPIface::initTransport()
+{
+    // let the server know who we are
+    sendTCP(sock, &rank, sizeof(rank));
+    // Let the server know our network address.  This is necessary for
+    // deterministic execution after restoring from a checkpoint - that's why
+    // we do not send this info right in the ctor.
+    sendTCP(sock, &networkAddress, sizeof(networkAddress));
+}
+
+void
+TCPIface::sendTCP(int sock, const void *buf, unsigned length)
 {
     ssize_t ret;
 
     ret = ::send(sock, buf, length, MSG_NOSIGNAL);
-    panic_if(ret < 0, "send() failed: %s", strerror(errno));
+    if (ret < 0) {
+        if (errno == ECONNRESET || errno == EPIPE) {
+            inform("send(): %s", strerror(errno));
+            exit_message("info", 0, "Message server closed connection, "
+                         "simulation is exiting");
+        } else {
+            panic("send() failed: %s", strerror(errno));
+        }
+    }
     panic_if(ret != length, "send() failed");
 }
 
@@ -140,19 +159,35 @@
 }
 
 void
-TCPIface::syncRaw(MultiHeaderPkt::MsgType sync_req, Tick sync_tick)
+TCPIface::sendPacket(const Header &header, const EthPacketPtr &packet)
 {
-    /*
-     * Barrier is simply implemented by point-to-point messages to the server
-     * for now. This method is called by only one TCPIface object.
-     * The server will send back an 'ack' message when it gets the
-     * sync request from all clients.
-     */
-    MultiHeaderPkt::Header header_pkt;
-    header_pkt.msgType = sync_req;
-    header_pkt.sendTick = sync_tick;
-
-    for (auto s : sockRegistry)
-        sendTCP(s, (void *)&header_pkt, sizeof(header_pkt));
+    sendTCP(sock, &header, sizeof(header));
+    sendTCP(sock, packet->data, packet->length);
 }
 
+void
+TCPIface::sendCmd(const Header &header)
+{
+    // Global commands (i.e. sync request) are always sent by the master
+    // MultiIface. The transfer method is simply implemented as point-to-point
+    // messages for now
+    for (auto s: sockRegistry)
+        sendTCP(s, (void*)&header, sizeof(header));
+}
+
+bool
+TCPIface::recvHeader(Header &header)
+{
+    return recvTCP(sock, &header, sizeof(header));
+}
+
+void
+TCPIface::recvPacket(const Header &header, EthPacketPtr &packet)
+{
+    packet = make_shared<EthPacketData>(header.dataPacketLength);
+    bool ret = recvTCP(sock, packet->data, header.dataPacketLength);
+    panic_if(!ret, "Error while reading socket");
+    packet->length = header.dataPacketLength;
+}
+
+
diff --git a/src/dev/tcp_iface.hh b/src/dev/tcp_iface.hh
--- a/src/dev/tcp_iface.hh
+++ b/src/dev/tcp_iface.hh
@@ -82,7 +82,7 @@
      * @param length Size of the message in bytes.
      */
     void
-    sendTCP(int sock, void *buf, unsigned length);
+    sendTCP(int sock, const void *buf, unsigned length);
 
     /**
      * Receive the next incoming message through a TCP stream socket.
@@ -96,21 +96,16 @@
 
   protected:
 
-    virtual void
-    sendRaw(void *buf, unsigned length,
-            const MultiHeaderPkt::AddressType dest_addr=nullptr)
-        M5_ATTR_OVERRIDE
-    {
-        sendTCP(sock, buf, length);
-    }
+    void sendPacket(const Header &header,
+                    const EthPacketPtr &packet) M5_ATTR_OVERRIDE;
 
-    virtual bool recvRaw(void *buf, unsigned length) M5_ATTR_OVERRIDE
-    {
-        return recvTCP(sock, buf, length);
-    }
+    void sendCmd(const Header &header) M5_ATTR_OVERRIDE;
 
-    virtual void syncRaw(MultiHeaderPkt::MsgType sync_req,
-                         Tick sync_tick) M5_ATTR_OVERRIDE;
+    bool recvHeader(Header &header) M5_ATTR_OVERRIDE;
+
+    void recvPacket(const Header &header, EthPacketPtr &packet) M5_ATTR_OVERRIDE;
+
+    void initTransport() M5_ATTR_OVERRIDE;
 
   public:
     /**
@@ -125,8 +120,8 @@
      * Ethernet link.
      */
     TCPIface(std::string server_name, unsigned server_port,
-             unsigned multi_rank, Tick sync_start, Tick sync_repeat,
-             EventManager *em);
+             unsigned multi_rank, unsigned multi_size,
+             Tick sync_start, Tick sync_repeat, EventManager *em);
 
     ~TCPIface() M5_ATTR_OVERRIDE;
 };
diff --git a/src/sim/global_event.hh b/src/sim/global_event.hh
--- a/src/sim/global_event.hh
+++ b/src/sim/global_event.hh
@@ -219,7 +219,7 @@
     };
 
     GlobalSyncEvent(Priority p, Flags f)
-        : Base(p, f)
+        : Base(p, f), repeat(0)
     { }
 
     GlobalSyncEvent(Tick when, Tick _repeat, Priority p, Flags f)
diff --git a/src/sim/initparam_keys.hh b/src/sim/initparam_keys.hh
new file mode 100644
--- /dev/null
+++ b/src/sim/initparam_keys.hh
@@ -0,0 +1,67 @@
+/*
+ * Copyright (c) 2015 ARM Limited
+ * All rights reserved
+ *
+ * The license below extends only to copyright in the software and shall
+ * not be construed as granting a license to any other intellectual
+ * property including but not limited to intellectual property relating
+ * to a hardware implementation of the functionality of the software
+ * licensed hereunder.  You may use the software subject to the license
+ * terms below provided that you ensure that this notice is replicated
+ * unmodified and in its entirety in all distributions of the software,
+ * modified or unmodified, in source code or in binary form.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met: redistributions of source code must retain the above copyright
+ * notice, this list of conditions and the following disclaimer;
+ * redistributions in binary form must reproduce the above copyright
+ * notice, this list of conditions and the following disclaimer in the
+ * documentation and/or other materials provided with the distribution;
+ * neither the name of the copyright holders nor the names of its
+ * contributors may be used to endorse or promote products derived from
+ * this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * Authors: Gabor Dozsa
+ */
+
+/* @file
+ * Magic key definitions for the InitParam pseudo inst
+ */
+#ifndef ___SIM_INITPARAM_KEYS_HH__
+#define ___SIM_INITPARAM_KEYS_HH__
+
+namespace PseudoInst {
+/**
+ * Magic keys to retrieve various params by the iniParam pseudo inst.
+ *
+ */
+struct InitParamKey {
+    /**
+     *  The default key (0)
+     */
+    static constexpr int DEFAULT = 0;
+    /**
+     *  Magic key for "rank" param (parallel multi-gem5 runs)
+     */
+    static constexpr int MULTI_RANK = 1234;
+    /**
+     *  Magic key for "size" param (parallel multi-gem5 runs)
+     */
+    static constexpr int MULTI_SIZE = 1235;
+};
+} // namespace PseudoInst
+
+#endif
diff --git a/src/sim/pseudo_inst.cc b/src/sim/pseudo_inst.cc
--- a/src/sim/pseudo_inst.cc
+++ b/src/sim/pseudo_inst.cc
@@ -63,8 +63,10 @@
 #include "debug/PseudoInst.hh"
 #include "debug/Quiesce.hh"
 #include "debug/WorkItems.hh"
+#include "dev/multi_iface.hh"
 #include "params/BaseCPU.hh"
 #include "sim/full_system.hh"
+#include "sim/initparam_keys.hh"
 #include "sim/process.hh"
 #include "sim/pseudo_inst.hh"
 #include "sim/serialize.hh"
@@ -141,7 +143,7 @@
         break;
 
       case 0x30: // initparam_func
-        return initParam(tc);
+        return initParam(tc, args[0]);
 
       case 0x31: // loadsymbol_func
         loadsymbol(tc);
@@ -357,8 +359,10 @@
 m5exit(ThreadContext *tc, Tick delay)
 {
     DPRINTF(PseudoInst, "PseudoInst::m5exit(%i)\n", delay);
-    Tick when = curTick() + delay * SimClock::Int::ns;
-    exitSimLoop("m5_exit instruction encountered", 0, when, 0, true);
+    if (MultiIface::readyToExit(delay)) {
+        Tick when = curTick() + delay * SimClock::Int::ns;
+        exitSimLoop("m5_exit instruction encountered", 0, when, 0, true);
+    }
 }
 
 void
@@ -440,15 +444,28 @@
 }
 
 uint64_t
-initParam(ThreadContext *tc)
+initParam(ThreadContext *tc, uint64_t key)
 {
-    DPRINTF(PseudoInst, "PseudoInst::initParam()\n");
+    DPRINTF(PseudoInst, "PseudoInst::initParam() key:%llu\n", key);
     if (!FullSystem) {
         panicFsOnlyPseudoInst("initParam");
         return 0;
     }
-
-    return tc->getCpuPtr()->system->init_param;
+    uint64_t val;
+    switch (key) {
+      case InitParamKey::DEFAULT:
+        val = tc->getCpuPtr()->system->init_param;
+        break;
+      case InitParamKey::MULTI_RANK:
+        val = MultiIface::rankParam();
+        break;
+      case InitParamKey::MULTI_SIZE:
+        val = MultiIface::sizeParam();
+        break;
+      default:
+        panic("Unknown key for initparam pseudo instruction");
+    }
+    return val;
 }
 
 
@@ -501,10 +518,11 @@
     if (!tc->getCpuPtr()->params()->do_checkpoint_insts)
         return;
 
-    Tick when = curTick() + delay * SimClock::Int::ns;
-    Tick repeat = period * SimClock::Int::ns;
-
-    exitSimLoop("checkpoint", 0, when, repeat);
+    if (MultiIface::readyToCkpt(delay, period)) {
+        Tick when = curTick() + delay * SimClock::Int::ns;
+        Tick repeat = period * SimClock::Int::ns;
+        exitSimLoop("checkpoint", 0, when, repeat);
+    }
 }
 
 uint64_t
diff --git a/src/sim/pseudo_inst.hh b/src/sim/pseudo_inst.hh
--- a/src/sim/pseudo_inst.hh
+++ b/src/sim/pseudo_inst.hh
@@ -75,7 +75,7 @@
     uint64_t offset, Addr filenameAddr);
 void loadsymbol(ThreadContext *xc);
 void addsymbol(ThreadContext *tc, Addr addr, Addr symbolAddr);
-uint64_t initParam(ThreadContext *xc);
+uint64_t initParam(ThreadContext *xc, uint64_t key);
 uint64_t rpns(ThreadContext *tc);
 void wakeCPU(ThreadContext *tc, uint64_t cpuid);
 void m5exit(ThreadContext *tc, Tick delay);
diff --git a/util/m5/m5.c b/util/m5/m5.c
--- a/util/m5/m5.c
+++ b/util/m5/m5.c
@@ -233,10 +233,12 @@
 void
 do_initparam(int argc, char *argv[])
 {
-    if (argc != 0)
+    if (argc > 1)
         usage();
 
-    uint64_t val = m5_initparam();
+    uint64_t key = 0;
+    parse_int_args(argc, argv, &key, 1);
+    uint64_t val = m5_initparam(key);
     printf("%"PRIu64, val);
 }
 
@@ -246,7 +248,7 @@
     if (argc != 0)
         usage();
 
-    uint64_t param = m5_initparam();
+    uint64_t param = m5_initparam(0);
 
     // run-time, rampup-time, rampdown-time, warmup-time, connections
     printf("%"PRId64" %"PRId64" %"PRId64" %"PRId64" %"PRId64,
@@ -298,7 +300,7 @@
     { "execfile",       do_exec_file,        "" },
     { "checkpoint",     do_checkpoint,       "[delay [period]]" },
     { "loadsymbol",     do_load_symbol,      "<address> <symbol>" },
-    { "initparam",      do_initparam,        "" },
+    { "initparam",      do_initparam,        "[key]" },
     { "sw99param",      do_sw99param,        "" },
 #ifdef linux
     { "pin",            do_pin,              "<cpu> <program> [args ...]" }
diff --git a/util/m5/m5op.h b/util/m5/m5op.h
--- a/util/m5/m5op.h
+++ b/util/m5/m5op.h
@@ -48,7 +48,7 @@
 
 void m5_exit(uint64_t ns_delay);
 void m5_fail(uint64_t ns_delay, uint64_t code);
-uint64_t m5_initparam(void);
+uint64_t m5_initparam(uint64_t key);
 void m5_checkpoint(uint64_t ns_delay, uint64_t ns_period);
 void m5_reset_stats(uint64_t ns_delay, uint64_t ns_period);
 void m5_dump_stats(uint64_t ns_delay, uint64_t ns_period);
diff --git a/util/multi/bootscript.rcS b/util/multi/bootscript.rcS
deleted file mode 100644
--- a/util/multi/bootscript.rcS
+++ /dev/null
@@ -1,122 +0,0 @@
-#!/bin/bash
-
-
-#
-# Copyright (c) 2015 ARM Limited
-# All rights reserved
-#
-# The license below extends only to copyright in the software and shall
-# not be construed as granting a license to any other intellectual
-# property including but not limited to intellectual property relating
-# to a hardware implementation of the functionality of the software
-# licensed hereunder.  You may use the software subject to the license
-# terms below provided that you ensure that this notice is replicated
-# unmodified and in its entirety in all distributions of the software,
-# modified or unmodified, in source code or in binary form.
-#
-# Redistribution and use in source and binary forms, with or without
-# modification, are permitted provided that the following conditions are
-# met: redistributions of source code must retain the above copyright
-# notice, this list of conditions and the following disclaimer;
-# redistributions in binary form must reproduce the above copyright
-# notice, this list of conditions and the following disclaimer in the
-# documentation and/or other materials provided with the distribution;
-# neither the name of the copyright holders nor the names of its
-# contributors may be used to endorse or promote products derived from
-# this software without specific prior written permission.
-#
-# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
-# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
-# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
-# A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-# OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
-# LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-# THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
-# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-#
-# Authors: Gabor Dozsa
-#
-#
-# This is an example boot script to use for muti gem5 runs. The important
-# task here is to extract the rank and size information from the kernel
-# boot args and use those to configure MAC/IP addresses and hostname.
-# Then we can kick off our (parallel) workload ...
-#
-# You are expected to costumize this scipt for your needs (e.g. change
-# the command at the end of the scipt to run your tests/workloads.
-
-source /root/.bashrc
-echo "bootscript.rcS is running"
-
-m='GEM5\_RANK=([0-9]+) GEM5\_SIZE=([0-9]+)'
-if [[ $(cat /proc/cmdline) =~ $m ]]
-then
-    MY_RANK=${BASH_REMATCH[1]}
-    MY_SIZE=${BASH_REMATCH[2]}
-else
-    echo "(E) GEM5_RANK/GEM5_SIZE was not defined in bootargs, exiting ..."
-    /sbin/m5 abort
-fi
-
-/bin/hostname node${MY_RANK}
-
-# Keep MAC address assignment simple for now ...
-(($MY_RANK>97)) && { echo "(E) Rank must be less than 98"; /sbin/m5 abort; }
-((MY_ADDR=MY_RANK+2))
-if (($MY_ADDR<10))
-then
-    MY_ADDR_PADDED=0${MY_ADDR}
-else
-    MY_ADDR_PADDED=${MY_ADDR}
-fi
-
-/sbin/ifconfig eth0 hw ether 00:90:00:00:00:${MY_ADDR_PADDED}
-/sbin/ifconfig eth0 192.168.0.${MY_ADDR} netmask 255.255.255.0 up
-
-/sbin/ifconfig -a
-
-# Prepare host lists for mpirun
-MY_MPI_HOSTS="192.168.0.2"
-for ((i=1; i<MY_SIZE; i++))
-do
-    MY_MPI_HOSTS+=",192.168.0.$((i+2))"
-done
-
-# Check that Ethernet links work, then take a checkpoint
-if  [ "$MY_RANK" == "0" ]
-then
-    OLDIFS=$IFS
-    IFS=","
-    for i in $MY_MPI_HOSTS
-    do
-        ping -c 1  $i || { echo "ping $i failed, exiting ..."; exit -1; }
-        ssh $i hostname || { echo "ssh $i failed, exiting ..."; exit -1; }
-    done
-    IFS=$OLDIFS
-    /sbin/m5 checkpoint
-fi
-
-# --------------------------------------------
-#  ------ Start your tests below ... ---------
-# --------------------------------------------
-
-if [ "$MY_RANK" == "0" ]
-then
-    echo "MPI test"
-    #mpirun -H 192.168.0.3,192.168.0.2 hostname
-    cd /benchmarks
-    mpirun -H $MY_MPI_HOSTS lulesh/lulesh2.0-mpi -s 5
-else
-    # This is to avoid other (rank!=0) gem5 processes exiting
-    # before the test (started by rank 0) completes. When rank 0 completes the
-    # test it will exit and that will trigger a notification to all the peer 
-    # gem5 peocesses to stop the simulation.
-    echo "sleep forever..."
-    while /bin/true
-    do
-        sleep 5
-    done
-fi
diff --git a/util/multi/gem5-multi.sh b/util/multi/gem5-multi.sh
--- a/util/multi/gem5-multi.sh
+++ b/util/multi/gem5-multi.sh
@@ -162,16 +162,20 @@
 {
     echo
     echo "KILLED $(date)"
-    # (try to) kill all gem5 processes on all hosts
+    # Try to Kill the server first. That should trigger an exit for all connectedd
+    # gem5 processes.
+    [ "x$SERVER_PID" != "x" ] && kill $SERVER_PID 2>/dev/null
+    sleep 20
+    # (try to) kill gem5 processes - just in case something went wrong with the
+    # server triggered exit
     bname=$(basename $GEM5_EXE)
-    killall -q $bname
+    killall -q -s SIGKILL $bname
     for h in ${HOSTS[@]}
     do
-        ssh $h killall -q $bname
+	ssh $h killall -q -s SIGKILL $bname
     done
-    sleep 3
-    # kill the message server and the watchdog
-    [ "x$SERVER_PID" != "x" ] && kill $SERVER_PID 2>/dev/null
+    sleep 5
+    # kill the watchdog
     [ "x$WATCHDOG_PID" != "x" ] && kill $WATCHDOG_PID 2>/dev/null
     exit -1
 }
@@ -200,20 +204,22 @@
     done
 }
 
-# This function launches the gem5 processes. We use it only to allow launching
-# gem5 processes under gdb control (in the foreground) for debugging
+# This function launches the gem5 processes. The only purpose is to enable
+# launching gem5 processes under gdb control for debugging
 start_func ()
 {
-    local N=$1
-    local HOST=$2
-    local ENV_ARGS=$3
-    shift 3
-    if [ "x$GEM5_DEBUG" != "x" ]
-    then
-        gdb --args "$@"
-    else
-        ssh $HOST $ENV_ARGS "$@" &>log.$N & 
-    fi
+      local N=$1
+      local HOST=$2
+      local ENV_ARGS=$3
+      shift 3
+      if [ "x$GEM5_DEBUG" != "x" ]
+      then
+	      echo "DEBUG starting terminal..."
+	      MY_ARGS="$@"
+	      xterm -e "gdb --args $MY_ARGS"
+      else
+        ssh $HOST $ENV_ARGS "$@" &>log.$N &
+      fi
 }
 
 
@@ -237,19 +243,20 @@
     h=${HOSTS[$i]}
     for ((j=0; j < ${NCORES[i]}; j++))
     do
-        echo "starting gem5 on $h ..."
-        start_func $n $h "$ENV_ARGS" $GEM5_EXE -d $(pwd)/m5out.$n $GEM5_ARGS \
-        --multi                                                              \
-        --multi-rank=$n                                                      \
+	    echo "starting gem5 on $h ..."
+	    start_func $n $h "$ENV_ARGS" $GEM5_EXE -d $(pwd)/m5out.$n $GEM5_ARGS \
+	    --multi                                                              \
+	    --multi-rank=$n                                                      \
+	    --multi-size=$NNODES                                                 \
         --multi-server-name=${HOSTS[0]}                                      \
-        --multi-server-port=$SERVER_PORT                                     \
-        --testsys-toplevel-LinuxArmSystem.boot_osflags="\"GEM5_RANK=$n GEM5_SIZE=$NNODES\""
-        SSH_PIDS[$n]=$!
-        ((n+=1))
+        --multi-server-port=$SERVER_PORT
+	    SSH_PIDS[$n]=$!
+	    ((n+=1))
     done
 done
 
-[ "x$GEM5_DEBUG" == "x" ] || {  kill $SERVER_PID; echo "DEBUG exit"; exit -1; }
+# Wait here if it is a debug session
+[ "x$GEM5_DEBUG" == "x" ] || {  echo "DEBUG session"; wait $SERVER_PID; exit -1; }
 
 # start watchdog to trigger complete abort (after a grace period) if any
 # gem5 process dies
diff --git a/util/multi/tcp_server.cc b/util/multi/tcp_server.cc
--- a/util/multi/tcp_server.cc
+++ b/util/multi/tcp_server.cc
@@ -50,8 +50,10 @@
 #include <sys/types.h>
 #include <unistd.h>
 
+#include <csignal>
 #include <cstdio>
 #include <cstdlib>
+#include <limits>
 
 #include "tcp_server.hh"
 
@@ -81,9 +83,11 @@
 
 TCPServer *TCPServer::instance = nullptr;
 
-TCPServer::Channel::Channel() : fd(-1), isAlive(false), state(SyncState::idle)
+TCPServer::Channel::Channel() :
+    fd(-1), isSync(false), connected(false), needExit(false), needCkpt(false)
 {
     MultiHeaderPkt::clearAddress(address);
+    newAddress.second = false;
 }
 
 unsigned
@@ -113,23 +117,32 @@
         panic("write() failed");
 }
 
-void TCPServer::Channel::updateAddress(const AddressType &new_address)
+void
+TCPServer::Channel::updateAddress(const AddressType &new_address)
 {
     // check if the known address has changed (e.g. the client reconfigured
     // its Ethernet NIC)
     if (MultiHeaderPkt::isAddressEqual(address, new_address))
         return;
 
+    MultiHeaderPkt::copyAddress(newAddress.first, new_address);
+    newAddress.second = true;
+}
+
+void
+TCPServer::Channel::updateAddressMap()
+{
+    assert(newAddress.second);
     // So we have to update the address. Note that we always
     // store the same address as key in the map but the ordering
     // may change so we need to erase and re-insert it again.
-    auto info = TCPServer::instance->addressMap.find(&address);
-    if (info != TCPServer::instance->addressMap.end()) {
-        TCPServer::instance->addressMap.erase(info);
+    auto m = TCPServer::instance->addressMap.find(&address);
+    if (m != TCPServer::instance->addressMap.end()) {
+        TCPServer::instance->addressMap.erase(m);
     }
-
-    MultiHeaderPkt::copyAddress(address, new_address);
+    MultiHeaderPkt::copyAddress(address, newAddress.first);
     TCPServer::instance->addressMap[&address] = this;
+    newAddress.second = false;
 }
 
 void
@@ -138,6 +151,8 @@
     ssize_t n;
     Header hdr_pkt;
 
+    assert (connected);
+
     n = recvRaw(&hdr_pkt, sizeof(hdr_pkt));
 
     if (n == 0) {
@@ -150,62 +165,42 @@
         updateAddress(hdr_pkt.srcAddress);
         TCPServer::instance->xferData(hdr_pkt, *this);
     } else {
-        processCmd(hdr_pkt.msgType, hdr_pkt.sendTick);
+        processCmd(hdr_pkt);
     }
 }
 
-void TCPServer::Channel::processCmd(MsgType cmd, Tick send_tick)
+void
+TCPServer::Channel::processCmd(Header &hdr_pkt)
 {
-    switch (cmd) {
-      case MsgType::cmdAtomicSyncReq:
-        DPRINTF(debugSync,"Atomic sync request (rank:%d)\n",rank);
-        assert(state == SyncState::idle);
-        state = SyncState::atomic;
-        TCPServer::instance->syncTryComplete(SyncState::atomic,
-                                             MsgType::cmdAtomicSyncAck);
+    switch (hdr_pkt.msgType) {
+      case MsgType::cmdSyncReq:
+        assert(isSync == false);
+        isSync = true;
+        TCPServer::instance->syncProgress(
+            hdr_pkt.sendTick,
+            hdr_pkt.syncRepeat,
+            hdr_pkt.sameTick,
+            rank);
         break;
-      case MsgType::cmdPeriodicSyncReq:
-        DPRINTF(debugPeriodic,"PERIODIC sync request (at %ld)\n",send_tick);
-        // sanity check
-        if (TCPServer::instance->periodicSyncTick() == 0) {
-            TCPServer::instance->periodicSyncTick(send_tick);
-        } else if ( TCPServer::instance->periodicSyncTick() != send_tick) {
-            panic("Out of order periodic sync request - rank:%d "
-                  "(send_tick:%ld ongoing:%ld)", rank, send_tick,
-                  TCPServer::instance->periodicSyncTick());
-        }
-        switch (state) {
-          case SyncState::idle:
-            state = SyncState::periodic;
-            TCPServer::instance->syncTryComplete(SyncState::periodic,
-                                                 MsgType::cmdPeriodicSyncAck);
-            break;
-          case SyncState::asyncCkpt:
-            // An async ckpt request has already been sent to this client and
-            // that will interrupt this periodic sync. We can simply drop this
-            // message.
-            break;
-          default:
-            panic("Unexpected state for periodic sync request (rank:%d)",
-                rank);
-            break;
-        }
+      case MsgType::cmdExitReq:
+        DPRINTF(debugSync, "EXIT request (rank %d tick %lu)\n",
+                rank, hdr_pkt.sendTick);
+        if (needExit)
+            inform("Multiple exit request (rank %d tick %lu)\n",
+                   rank, hdr_pkt.sendTick);
+        else
+            TCPServer::instance->numExitReq++;
+        needExit = true;
         break;
-      case MsgType::cmdCkptSyncReq:
-        DPRINTF(debugSync, "CKPT sync request (rank:%d)\n",rank);
-        switch (state) {
-          case SyncState::idle:
-            TCPServer::instance->ckptPropagate(*this);
-            // we fall through here to complete #clients==1 case
-          case SyncState::asyncCkpt:
-            state = SyncState::ckpt;
-            TCPServer::instance->syncTryComplete(SyncState::ckpt,
-                                                 MsgType::cmdCkptSyncAck);
-            break;
-          default:
-            panic("Unexpected state for ckpt sync request (rank:%d)", rank);
-            break;
-        }
+      case MsgType::cmdCkptReq:
+        DPRINTF(debugSync, "CKPT request (rank %d tick %lu)\n",
+                rank, hdr_pkt.sendTick);
+        if (needCkpt)
+            inform("Multiple ckpt request (rank:%d tick:%lu\n",
+                   rank, hdr_pkt.sendTick);
+        else
+            TCPServer::instance->numCkptReq++;
+        needCkpt = true;
         break;
       default:
         panic("Unexpected header packet (rank:%d)",rank);
@@ -215,7 +210,14 @@
 
 TCPServer::TCPServer(unsigned clients_num,
                      unsigned listen_port,
-                     int timeout_in_sec)
+                     int timeout_in_sec) :
+    nextSyncRepeat(std::numeric_limits<Tick>::max()),
+    maxSyncReqTick(0),
+    isSameTickSync(false),
+    numSyncReq(0),
+    numCkptReq(0),
+    numExitReq(0),
+    numConnectedClients(0)
 {
     assert(instance == nullptr);
     construct(clients_num, listen_port, timeout_in_sec);
@@ -273,8 +275,16 @@
         new_pollfd.revents = 0;
         clientsPollFd.push_back(new_pollfd);
         new_channel.fd = new_sock;
-        new_channel.isAlive = true;
+        new_channel.connected = true;
+        // Get rank from the client
         new_channel.recvRaw(&new_channel.rank, sizeof(new_channel.rank));
+        // Get initial network address
+        new_channel.recvRaw(&new_channel.newAddress.first,
+                            sizeof(new_channel.newAddress.first));
+        new_channel.newAddress.second =
+            !MultiHeaderPkt::isAddressEqual(new_channel.address,
+                                            new_channel.newAddress.first);
+
         clientsChannel.push_back(new_channel);
 
         DPRINTF(debugSetup, "New client connection addr:%u port:%hu rank:%d\n",
@@ -291,16 +301,16 @@
 TCPServer::run()
 {
     int nfd;
-    unsigned num_active_clients = clientsPollFd.size();
+    numConnectedClients = clientsPollFd.size();
 
     DPRINTF(debugSetup, "Entering run() loop\n");
-    while (num_active_clients ==  clientsPollFd.size()) {
+    while (numConnectedClients > 0) {
         nfd = poll(&clientsPollFd[0], clientsPollFd.size(), -1);
         if (nfd == -1)
             panic("poll() failed:%s", strerror(errno));
 
         for (unsigned i = 0, n = 0;
-             i < clientsPollFd.size() && (signed)n < nfd;
+             i < clientsPollFd.size() && (signed)n < nfd && numConnectedClients;
              i++) {
             struct pollfd &pfd = clientsPollFd[i];
             if (pfd.revents) {
@@ -310,25 +320,41 @@
                     clientsChannel[i].headerPktIn();
                 }
                 if (pfd.revents & POLLRDHUP) {
-                    // One gem5 process exited or aborted. Either way, we
-                    // assume the full simulation should stop now (either
-                    // because m5 exit was called or a serious error
-                    // occurred.) So we quit the run loop here and close all
-                    // sockets to notify the remaining peer gem5 processes.
+                    // One gem5 process exited or aborted.
                     pfd.events = 0;
-                    clientsChannel[i].isAlive = false;
-                    num_active_clients--;
-                    DPRINTF(debugSetup, "POLLRDHUP event");
+                    if (!processExitEvent(clientsChannel[i])) {
+                        numConnectedClients = 0;
+                        break;
+                    } else {
+                        numConnectedClients--;
+                    }
                 }
                 n++;
-                if ((signed)n == nfd)
-                    break;
             }
         }
     }
     DPRINTF(debugSetup, "Exiting run() loop\n");
 }
 
+bool
+TCPServer::processExitEvent(Channel &ch)
+{
+
+    DPRINTF(debugSetup, "POLLRDHUP event (rank:%d, needExit:%d)\n",
+            ch.rank, (int)ch.needExit);
+    assert (ch.connected);
+
+    // Sanity check
+    for (auto &c : clientsChannel) {
+        if ((ch.needExit != c.needExit) || c.isSync || c.needCkpt)
+            panic("Client %d closed connection unexpectedly whilst client %d"
+                  "is active (needExit %d isSync %d needCkpt %d)",
+                  ch.rank, c.rank, c.needExit, c.isSync, c.needCkpt);
+    }
+    ch.connected = false;
+    return ch.needExit;
+}
+
 void
 TCPServer::xferData(const Header &hdr_pkt, const Channel &src)
 {
@@ -363,7 +389,7 @@
         dst_info == addressMap.end()) {
         unsigned n = 0;
         for (auto const &c: clientsChannel) {
-            if (c.isAlive && &c!=&src) {
+            if (c.connected && (&c != &src)) {
                 c.sendRaw(&hdr_pkt, sizeof(hdr_pkt));
                 c.sendRaw(packetBuffer, hdr_pkt.dataPacketLength);
                 n++;
@@ -375,68 +401,94 @@
     } else {
         // It is a unicast address with a known destination
         Channel *dst = dst_info->second;
-        if (dst->isAlive) {
+        if ( dst->connected) {
             dst->sendRaw(&hdr_pkt, sizeof(hdr_pkt));
             dst->sendRaw(packetBuffer, hdr_pkt.dataPacketLength);
-            DPRINTF(debugPkt, "Unicast packet sent (to rank %d)\n",dst->rank);
+            DPRINTF(debugPkt, "Unicast packet sent (from/to rank %d/%d)\n",
+                    src.rank, dst->rank);
         } else {
-            inform("Unicast packet dropped (destination exited)\n");
+            inform("Unicast packet dropped - destination exited "
+                   "(from/to rank %d/%d\n", src.rank, dst->rank);
         }
     }
 }
 
 void
-TCPServer::syncTryComplete(SyncState st, MsgType ack)
+TCPServer::syncProgress(Tick send_tick, Tick next_sync_repeat,
+                        bool same_tick, unsigned rank)
 {
-    // Check if the barrieris complete. If so then notify all the clients.
+    DPRINTF(same_tick ? debugPeriodic : debugSync,
+            "Sync request rank:%d tick:%lu\n", rank, send_tick);
+
+    assert(numSyncReq == 0 || (same_tick == isSameTickSync));
+    assert(!same_tick || (numSyncReq == 0) ||
+           (isSameTickSync && (maxSyncReqTick == send_tick)));
+    isSameTickSync = same_tick;
+    if (maxSyncReqTick < send_tick)
+        maxSyncReqTick = send_tick;
+
+    if (next_sync_repeat < nextSyncRepeat) {
+        nextSyncRepeat = next_sync_repeat;
+        inform("Periodic sync repeat is adjusted to %lu\n", nextSyncRepeat);
+    }
+    assert(numSyncReq < numConnectedClients);
+    numSyncReq++;
+    if (numSyncReq < numConnectedClients)
+        return;
+
+    // Sync complete, send out the acks
+    MultiHeaderPkt::Header hdr_pkt;
+    hdr_pkt.msgType = MsgType::cmdSyncAck;
+    hdr_pkt.maxSyncReqTick = maxSyncReqTick;
+    hdr_pkt.syncRepeat = nextSyncRepeat;
+    assert(numCkptReq <= numConnectedClients);
+
+    bool coll_ckpt = (numCkptReq == numConnectedClients);
+    if (coll_ckpt) {
+        hdr_pkt.doCkpt = true;
+        numCkptReq = 0;
+    } else {
+        hdr_pkt.doCkpt = false;
+    }
+
+    assert(numExitReq <= numConnectedClients);
+    if (numExitReq == numConnectedClients) {
+        hdr_pkt.doExit =  true;
+        numExitReq = 0;
+    } else {
+        hdr_pkt.doExit = false;
+    }
+
     for (auto &c : clientsChannel) {
-        if (c.isAlive && (c.state != st)) {
-            // sync not complete yet, stop here
-            return;
+        if (c.connected) {
+            c.sendRaw(&hdr_pkt, sizeof(hdr_pkt));
+            c.isSync = false;
+            if (coll_ckpt)
+                c.needCkpt = false;
+            // Update the address map at each peridoc sync if the channel has
+            // new address
+            if (c.newAddress.second == true && isSameTickSync)
+                c.updateAddressMap();
         }
     }
-    // Sync complete, send out the acks
-    MultiHeaderPkt::Header hdr_pkt;
-    hdr_pkt.msgType = ack;
-    for (auto &c : clientsChannel) {
-        if (c.isAlive) {
-            c.sendRaw(&hdr_pkt, sizeof(hdr_pkt));
-            c.state = SyncState::idle;
-        }
-    }
-    // Reset periodic send tick
-    _periodicSyncTick = 0;
-    DPRINTF(st == SyncState::periodic ? debugPeriodic : debugSync,
-            "Sync COMPLETE\n");
+    DPRINTF(isSameTickSync ? debugPeriodic : debugSync, "Sync COMPLETE\n");
+    numSyncReq = 0;
+    maxSyncReqTick = 0;
+    isSameTickSync = false;
 }
 
 void
-TCPServer::ckptPropagate(Channel &ch)
+sigtermHandler(int sig)
 {
-    // Channel ch got a ckpt request that needs to be propagated to the other
-    // clients
-    MultiHeaderPkt::Header hdr_pkt;
-    hdr_pkt.msgType = MsgType::cmdCkptSyncReq;
-    for (auto &c : clientsChannel) {
-        if (c.isAlive && (&c != &ch)) {
-            switch (c.state) {
-              case SyncState::idle:
-              case SyncState::periodic:
-                c.sendRaw(&hdr_pkt, sizeof(hdr_pkt));
-                c.state = SyncState::asyncCkpt;
-                break;
-              default:
-                panic("Unexpected state for ckpt sync request propagation "
-                      "(rank:%d)\n",c.rank);
-                break;
-            }
-        }
-    }
+    if (TCPServer::getInstance() != nullptr)
+        delete TCPServer::getInstance();
+    panic("Got SIGTERM\n");
 }
 
-int main(int argc, char *argv[])
+int
+main(int argc, char *argv[])
 {
-    TCPServer *server;
+    TCPServer *server = nullptr;
     int clients_num = -1, listen_port = -1;
     int first_arg = 1, timeout_in_sec = 60;
 
@@ -450,6 +502,8 @@
         panic("We need two command line args (number of clients and tcp listen"
               " port");
 
+    signal(SIGTERM, sigtermHandler);
+
     clients_num = atoi(argv[first_arg]);
     listen_port = atoi(argv[first_arg + 1]);
 
diff --git a/util/multi/tcp_server.hh b/util/multi/tcp_server.hh
--- a/util/multi/tcp_server.hh
+++ b/util/multi/tcp_server.hh
@@ -77,7 +77,6 @@
 #include <map>
 #include <vector>
 
-#include "dev/etherpkt.hh"
 #include "dev/multi_packet.hh"
 
 /**
@@ -93,9 +92,6 @@
     typedef MultiHeaderPkt::MsgType MsgType;
 
   private:
-
-    enum
-    class SyncState { periodic, ckpt, asyncCkpt, atomic, idle };
     /**
      * The Channel class encapsulates all the information about a client
      * and its current status.
@@ -104,11 +100,6 @@
     {
       private:
         /**
-         * The MAC address of the client.
-         */
-        AddressType address;
-
-        /**
          * Update the client MAC address. It is called every time a new data
          * packet is to come in.
          */
@@ -116,8 +107,7 @@
         /**
          * Process an incoming command message.
          */
-        void processCmd(MultiHeaderPkt::MsgType cmd, Tick send_tick);
-
+        void processCmd(Header &hdr_packet);
 
       public:
         /**
@@ -125,23 +115,42 @@
          */
         int fd;
         /**
-         * Is client connected?
+         * Flag for on-going sync
          */
-        bool isAlive;
+        bool isSync;
         /**
-         * Current state of the channel wrt. multi synchronisation.
-         */
-        SyncState state;
-        /**
-         * Multi rank of the client
+         *  Multi rank of the client
          */
         unsigned rank;
+        /**
+         * Flag to is true if client is connected
+         */
+        bool connected;
+        /**
+         * Flag to is true if client has requested exit
+         */
+        bool needExit;
+        /**
+         * Flag to is true if client has requested checkppint
+         */
+        bool needCkpt;
+        /**
+         * Current network address of the client
+         */
+        AddressType address;
+        /**
+         * New network address of the client.
+         *
+         * @note For the sake of deterministic runs, we do not use an updated
+         * address until the next periodic sync completes. That avoids race
+         * conditions regarding broadcast/unicast data packets.
+         */
+        typedef std::pair<AddressType,bool> AddressInfo;
+        AddressInfo newAddress;
 
       public:
         Channel();
         ~Channel () {}
-
-
         /**
          * Receive and process the next incoming header packet.
          */
@@ -154,6 +163,12 @@
          */
         void sendRaw(const void *data, unsigned size) const;
         /**
+         * Register an address change in the address map.
+         *
+         * @note This method is only called when a periodic sync completes
+         */
+        void updateAddressMap();
+        /**
          * Receive raw data from the connected client.
          *
          * @param buf The buffer to store the incoming data into.
@@ -163,7 +178,6 @@
          */
         unsigned recvRaw(void *buf, unsigned size) const;
     };
-
     /**
      * The array of socket descriptors needed by the poll() system call.
      */
@@ -172,8 +186,6 @@
      * Array holding all clients info.
      */
     std::vector<Channel> clientsChannel;
-
-
     /**
      * We use a map to select the target client based on the destination
      * MAC address.
@@ -186,29 +198,51 @@
         }
     };
     std::map<const AddressType *, Channel *, AddressCompare> addressMap;
-
     /**
      * As we dealt with only one message at a time, we can allocate and re-use
      * a single packet buffer (to hold any incoming data packet).
      */
     uint8_t packetBuffer[MAX_ETH_PACKET_LENGTH];
     /**
-     * Send tick of the current periodic sync. It is used for sanity check.
+     * The repeat value for the next periodic sync
      */
-    Tick _periodicSyncTick;
+    Tick nextSyncRepeat;
+    /**
+     * Max send tick of the current sync.
+     */
+    Tick maxSyncReqTick;
+    /*
+     * Is the current sync must happen at the same tick in clients?
+     */
+    bool isSameTickSync;
+    /*
+     * Number of current sync requets.
+     */
+    unsigned numSyncReq;
+    /*
+     * Number of current ckpt requests.
+     */
+    unsigned numCkptReq;
+    /*
+     * Number of current exit requests.
+     */
+    unsigned numExitReq;
+    /*
+     * Number of connected clients.
+     */
+    unsigned numConnectedClients;
     /**
      * The singleton server object.
      */
     static TCPServer *instance;
-
     /**
      * Set up the socket connections to all the clients.
      *
      * @param listen_port The port we are listening on for new client
      * connection requests.
      * @param nclients The number of clients to connect to.
-     * @param timeout Timeout in sec to complete the setup phase
-     * (i.e. all gem5 establish socket connections)
+     * @param timeout Timeout in sec to complete the setup phase (i.e. all gem5
+     * establish socket connections)
      */
     void construct(unsigned listen_port, unsigned nclients, int timeout);
     /**
@@ -220,27 +254,17 @@
      */
     void xferData(const Header &hdr, const Channel &ch);
     /**
-     * Check if the current round of a synchronisation is completed and notify
-     * the clients if it is so.
+     * Process a new sync request.
+     */
+    void syncProgress(Tick send_tick, Tick sync_repeat, bool is_periodic, unsigned rank);
+    /**
+     * Process a client exit event
      *
-     * @param st The state all channels should have if sync is complete.
-     * @param ack The type of ack message to send out if the sync is compete.
+     * @param ch The channel on which the client exit event occured.
+     *
+     * @return False if this event must trigger a global exit.
      */
-    void syncTryComplete(SyncState st, MultiHeaderPkt::MsgType ack);
-    /**
-     * Broadcast a request for checkpoint sync.
-     *
-     * @param ch The source channel of the checkpoint sync request.
-     */
-    void ckptPropagate(Channel &ch);
-    /**
-     * Setter for current periodic send tick.
-     */
-    void periodicSyncTick(Tick t) { _periodicSyncTick = t; }
-    /**
-     * Getter for current periodic send tick.
-     */
-    Tick periodicSyncTick() { return _periodicSyncTick; }
+    bool processExitEvent(Channel &ch);
 
   public:
 
@@ -251,4 +275,8 @@
      * The main server loop that waits for and processes incoming messages.
      */
     void run();
+    /**
+     * The singleton server object.
+     */
+  static TCPServer *getInstance() { return instance; }
 };
diff --git a/util/multi/test/bootscript.rcS b/util/multi/test/bootscript.rcS
new file mode 100644
--- /dev/null
+++ b/util/multi/test/bootscript.rcS
@@ -0,0 +1,101 @@
+#!/bin/bash
+
+
+#
+# Copyright (c) 2015 ARM Limited
+# All rights reserved
+#
+# The license below extends only to copyright in the software and shall
+# not be construed as granting a license to any other intellectual
+# property including but not limited to intellectual property relating
+# to a hardware implementation of the functionality of the software
+# licensed hereunder.  You may use the software subject to the license
+# terms below provided that you ensure that this notice is replicated
+# unmodified and in its entirety in all distributions of the software,
+# modified or unmodified, in source code or in binary form.
+#
+# Redistribution and use in source and binary forms, with or without
+# modification, are permitted provided that the following conditions are
+# met: redistributions of source code must retain the above copyright
+# notice, this list of conditions and the following disclaimer;
+# redistributions in binary form must reproduce the above copyright
+# notice, this list of conditions and the following disclaimer in the
+# documentation and/or other materials provided with the distribution;
+# neither the name of the copyright holders nor the names of its
+# contributors may be used to endorse or promote products derived from
+# this software without specific prior written permission.
+#
+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+# A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+# OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+# LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+# THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+#
+# Authors: Gabor Dozsa
+#
+#
+# This is an example boot script to use for multi gem5 runs. The important
+# task here is to extract the rank and size information through the m5
+# initparam utility and use those to configure MAC/IP addresses and hostname.
+#
+# You are expected to customize this scipt for your needs (e.g. change
+# the command at the end of the scipt to run your tests/workloads.
+
+source /root/.bashrc
+echo "bootscript.rcS is running"
+
+# Retrieve multi-gem5 rank and size parameters using magic keys
+MY_RANK=$(/sbin/m5 initparam 1234)
+MY_SIZE=$(/sbin/m5 initparam 1235)
+
+/bin/hostname node${MY_RANK}
+
+# Keep MAC address assignment simple for now ...
+(($MY_RANK > 97)) && { echo "(E) Rank must be less than 98"; /sbin/m5 abort; }
+((MY_ADDR = MY_RANK + 2))
+if (($MY_ADDR < 10))
+then
+    MY_ADDR_PADDED=0${MY_ADDR}
+else
+    MY_ADDR_PADDED=${MY_ADDR}
+fi
+
+/sbin/ifconfig eth0 hw ether 00:90:00:00:00:${MY_ADDR_PADDED}
+/sbin/ifconfig eth0 192.168.0.${MY_ADDR} netmask 255.255.255.0 up
+
+/sbin/ifconfig -a
+
+echo "Hello from $MY_RANK of $MY_SIZE"
+
+# Now that our network interface is configured we can use the usual commands to
+# contact the other systems, e.g. let's try to ping a "neighbour" system
+if ((MY_RANK < MY_SIZE - 1))
+then
+    ping -c 1 192.168.0.$((MY_ADDR + 1))
+else
+    ping -c 1 192.168.0.2
+fi
+
+
+if [ "$MY_RANK" == "0" ]
+then
+    /sbin/m5 checkpoint
+    echo "A real multi node workload might start here ..."
+    /sbin/m5 exit 0
+else
+    # This is to avoid other (rank!=0) gem5 processes exiting
+    # before the test (started by rank 0) completes. When rank 0 completes the
+    # test it will exit and that will trigger a notification to all the peer
+    # gem5 processes to stop the simulation.
+    echo "sleep forever..."
+    while /bin/true
+    do
+	sleep 5
+    done
+fi
diff --git a/util/multi/test/test-2nodes-AArch64.sh b/util/multi/test/test-2nodes-AArch64.sh
new file mode 100644
--- /dev/null
+++ b/util/multi/test/test-2nodes-AArch64.sh
@@ -0,0 +1,73 @@
+#! /bin/bash
+
+#
+# Copyright (c) 2015 ARM Limited
+# All rights reserved
+#
+# The license below extends only to copyright in the software and shall
+# not be construed as granting a license to any other intellectual
+# property including but not limited to intellectual property relating
+# to a hardware implementation of the functionality of the software
+# licensed hereunder.  You may use the software subject to the license
+# terms below provided that you ensure that this notice is replicated
+# unmodified and in its entirety in all distributions of the software,
+# modified or unmodified, in source code or in binary form.
+#
+# Redistribution and use in source and binary forms, with or without
+# modification, are permitted provided that the following conditions are
+# met: redistributions of source code must retain the above copyright
+# notice, this list of conditions and the following disclaimer;
+# redistributions in binary form must reproduce the above copyright
+# notice, this list of conditions and the following disclaimer in the
+# documentation and/or other materials provided with the distribution;
+# neither the name of the copyright holders nor the names of its
+# contributors may be used to endorse or promote products derived from
+# this software without specific prior written permission.
+#
+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+# A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+# OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+# LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+# THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+#
+# Authors: Gabor Dozsa
+#
+#
+# This is an example script to start a multi gem5 simulations using
+# two AArch64 systems. It is also uses the example
+# multi gem5 bootscript util/multi/test/bootscript.rcS that will run the
+# linux ping command to check if we can see the peer system connected via
+# the simulated Ethernet link.
+
+GEM5_DIR=$(pwd)/$(dirname $0)/../../..
+
+IMG=$M5_PATH/disks/aarch64-ubuntu-trusty-headless.img
+VMLINUX=$M5_PATH/binaries/vmlinux.aarch64.20140821
+DTB=$M5_PATH/binaries/vexpress.aarch64.20140821.dtb
+
+SYS_CONFIG=$GEM5_DIR/configs/example/fs.py
+GEM5_EXE=$GEM5_DIR/build/ARM/gem5.opt
+
+BOOT_SCRIPT=$GEM5_DIR/util/multi/test/bootscript.rcS
+GEM5_MULTI_SH=$GEM5_DIR/util/multi/gem5-multi.sh
+
+#DEBUG_FLAGS="--debug-flags=MultiEthernet"
+#CHKPT_RESTORE="-r1"
+
+NNODES=2
+
+$GEM5_MULTI_SH -n $NNODES $GEM5_EXE $DEBUG_FLAGS $SYS_CONFIG   \
+    --cpu-type=atomic                                          \
+    --num-cpus=1                                               \
+    --machine-type=VExpress_EMM64                              \
+    --disk-image=$IMG                                          \
+    --kernel=$VMLINUX                                          \
+    --dtb-filename=$DTB                                        \
+    --script=$BOOT_SCRIPT                                      \
+    $CHKPT_RESTORE
